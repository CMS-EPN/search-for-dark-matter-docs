
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Search for dark matter produced in association with a single top quark or a top quark pair in proton-proton collisions at √s = 13 TeV">
      
      
      
        <link rel="canonical" href="https://cms-epn.github.io/search-for-dark-matter-docs/Single_Lepton/Analisis_muon_final_version/">
      
      
        <link rel="prev" href="../../All_Hadronic/all%20hadronic%20si/">
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Advances of the Project - Search for dark matter</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i,700,700i%7CRed+Hat+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Merriweather Sans";--md-code-font:"Red Hat Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="blue-grey">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#advances-of-the-project" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Search for dark matter" class="md-header__button md-logo" aria-label="Search for dark matter" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 11a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1M4.22 4.22C5.65 2.79 8.75 3.43 12 5.56c3.25-2.13 6.35-2.77 7.78-1.34s.79 4.53-1.34 7.78c2.13 3.25 2.77 6.35 1.34 7.78s-4.53.79-7.78-1.34c-3.25 2.13-6.35 2.77-7.78 1.34S3.43 15.25 5.56 12C3.43 8.75 2.79 5.65 4.22 4.22m11.32 4.24c.61.62 1.17 1.25 1.69 1.88 1.38-2.13 1.88-3.96 1.13-4.7-.74-.75-2.57-.25-4.7 1.13.63.52 1.26 1.08 1.88 1.69m-7.08 7.08c-.61-.62-1.17-1.25-1.69-1.88-1.38 2.13-1.88 3.96-1.13 4.7.74.75 2.57.25 4.7-1.13-.63-.52-1.26-1.08-1.88-1.69m-2.82-9.9c-.75.74-.25 2.57 1.13 4.7.52-.63 1.08-1.26 1.69-1.88.62-.61 1.25-1.17 1.88-1.69-2.13-1.38-3.96-1.88-4.7-1.13m4.24 8.48c.7.7 1.42 1.34 2.12 1.91.7-.57 1.42-1.21 2.12-1.91s1.34-1.42 1.91-2.12c-.57-.7-1.21-1.42-1.91-2.12S12.7 8.54 12 7.97c-.7.57-1.42 1.21-2.12 1.91S8.54 11.3 7.97 12c.57.7 1.21 1.42 1.91 2.12m8.48 4.24c.75-.74.25-2.57-1.13-4.7-.52.63-1.08 1.26-1.69 1.88-.62.61-1.25 1.17-1.88 1.69 2.13 1.38 3.96 1.88 4.7 1.13"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Search for dark matter
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Advances of the Project
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="blue-grey"  aria-label="Dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="deep-orange"  aria-label="Light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/CMS-EPN/search-for-dark-matter-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    search-for-dark-matter-docs
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Search for dark matter" class="md-nav__button md-logo" aria-label="Search for dark matter" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 11a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1M4.22 4.22C5.65 2.79 8.75 3.43 12 5.56c3.25-2.13 6.35-2.77 7.78-1.34s.79 4.53-1.34 7.78c2.13 3.25 2.77 6.35 1.34 7.78s-4.53.79-7.78-1.34c-3.25 2.13-6.35 2.77-7.78 1.34S3.43 15.25 5.56 12C3.43 8.75 2.79 5.65 4.22 4.22m11.32 4.24c.61.62 1.17 1.25 1.69 1.88 1.38-2.13 1.88-3.96 1.13-4.7-.74-.75-2.57-.25-4.7 1.13.63.52 1.26 1.08 1.88 1.69m-7.08 7.08c-.61-.62-1.17-1.25-1.69-1.88-1.38 2.13-1.88 3.96-1.13 4.7.74.75 2.57.25 4.7-1.13-.63-.52-1.26-1.08-1.88-1.69m-2.82-9.9c-.75.74-.25 2.57 1.13 4.7.52-.63 1.08-1.26 1.69-1.88.62-.61 1.25-1.17 1.88-1.69-2.13-1.38-3.96-1.88-4.7-1.13m4.24 8.48c.7.7 1.42 1.34 2.12 1.91.7-.57 1.42-1.21 2.12-1.91s1.34-1.42 1.91-2.12c-.57-.7-1.21-1.42-1.91-2.12S12.7 8.54 12 7.97c-.7.57-1.42 1.21-2.12 1.91S8.54 11.3 7.97 12c.57.7 1.21 1.42 1.91 2.12m8.48 4.24c.75-.74.25-2.57-1.13-4.7-.52.63-1.08 1.26-1.69 1.88-.62.61-1.25 1.17-1.88 1.69 2.13 1.38 3.96 1.88 4.7 1.13"/></svg>

    </a>
    Search for dark matter
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CMS-EPN/search-for-dark-matter-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    search-for-dark-matter-docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    EPN CMS collaboration
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    All Hadronic
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    All Hadronic
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../All_Hadronic/all%20hadronic%20si/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Complete Guide: AH Optimization Analysis for CMS Open Data
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Single Lepton
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Single Lepton
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Advances of the Project
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Advances of the Project
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#title-objective" class="md-nav__link">
    <span class="md-ellipsis">
      
        Title / Objective:
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#title-objective" class="md-nav__link">
    <span class="md-ellipsis">
      
        Title / Objective:
      
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="advances-of-the-project">Advances of the Project</h1>
<h2 id="title-objective">Title / Objective:</h2>
<p>Reproducible Analysis of CMS Open Data: Search for Dark Matter in Association with Top Quarks
(Based on the CMS publication: “Search for dark matter produced in association with a single top quark or a top quark pair in proton–proton collisions at (<span class="arithmatex">\(\sqrt s = 13 \TeV\)</span>”).</p>
<h1 id="physics-motivation-and-channel-strategy">Physics Motivation and Channel Strategy</h1>
<p>The Large Hadron Collider (LHC) collides protons at center-of-mass energies high enough to probe physics beyond the Standard Model. Although the protons are composite objects, the relevant hard scatterings occur between their constituents — quarks and gluons. In the context of simplified dark matter models, these partonic interactions can produce <strong>top quarks</strong> together with a new mediator particle (commonly denoted φ for scalar or a for pseudoscalar). The mediator then decays invisibly into a pair of dark matter candidates (<span class="arithmatex">\(\chi \bar{\chi}\)</span>). At the detector level, this results in events with multiple top quarks plus significant <strong>missing transverse momentum</strong> (<span class="arithmatex">\(p_T^{\text{miss}}\)</span>), the latter coming from both neutrinos and the invisible χ particles.</p>
<p>The production mechanisms of interest include:  </p>
<ul>
<li>
<p><strong>Gluon fusion</strong>:<br />
  $$ gg \to t \bar{t}\,\phi \to t \bar{t} + \chi \bar{\chi} $$  </p>
</li>
<li>
<p><strong>Single top associated production</strong>:<br />
  $$ gb \to t \phi \to t + \chi \bar{\chi} $$  </p>
</li>
<li>
<p><strong>t–channel production</strong>:<br />
  $$ qq' \to tb \phi \to tb + \chi \bar{\chi} $$  </p>
</li>
</ul>
<p>In all cases, the top quarks decay via <span class="arithmatex">\(t \to W b\)</span>. Each W boson subsequently decays either leptonically (<span class="arithmatex">\(W \to \ell \nu\)</span>) or hadronically (<span class="arithmatex">\(W \to q \bar{q}'\)</span>). Thus, the final states contain a mixture of b-tagged jets, light-flavor jets, charged leptons (electrons or muons), and genuine <span class="arithmatex">\(p_T^{\text{miss}}\)</span>. The specific experimental signature depends strongly on the decay mode of the W bosons.</p>
<p>Because of this, analyses are divided into <strong>channels</strong>, each defined by the number of isolated charged leptons:</p>
<ul>
<li><strong>Single-lepton (SL):</strong> one isolated electron or muon, several jets (including ≥1 b-tag), and nonzero <span class="arithmatex">\(p_T^{\text{miss}}\)</span>. This channel is statistically powerful and relatively clean, striking a balance between signal sensitivity and manageable backgrounds.  </li>
<li><strong>All-hadronic (AH):</strong> no isolated leptons, many jets including b-tagged jets, and <span class="arithmatex">\(p_T^{\text{miss}}\)</span>. While it has the largest raw yield, it suffers from overwhelming QCD multijet background, which can fake <span class="arithmatex">\(p_T^{\text{miss}}\)</span>.  </li>
<li><strong>Dilepton:</strong> two isolated leptons, large <span class="arithmatex">\(p_T^{\text{miss}}\)</span>, and multiple jets. It provides a very clean signal region but is limited by low branching fraction, hence low statistics.</li>
</ul>
<p>In this notebook, we concentrate on the <strong>single-lepton channel with exactly one muon</strong>. There are both theoretical and practical reasons for this choice. From the physics side, the SL channel has the right compromise: it suppresses pure QCD while retaining enough events to make meaningful comparisons. From the experimental side, single-muon triggers are robust, well understood in CMS, and ensure efficient data collection. This focus allows us to demonstrate the full workflow — from event selection to histograms — in a setting where the interplay between <strong>signal characteristics</strong> and <strong>background processes</strong> can be clearly explained. Splitting into channels is therefore not a stylistic decision but a physics necessity: each final state probes the same underlying processes under different background conditions and detector signatures.</p>
<hr />
<p>After defining the objective of the project (Reproducible Analysis of CMS Open Data), we discussed in which data format to work — NanoAOD or MiniAOD. We decided to use NanoAOD, because it is lighter and optimized for analysis tasks.</p>
<p>In the most precise version, we work within cernbox/swan, but it can work in any Jupyter environment; the important packages are: uproot and awkward</p>
<h2 id="single-lepton">Single Lepton</h2>
<p>We import all the libraries that we are going to use.</p>
<pre><code class="language-python">%load_ext autoreload
%autoreload 2

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import hist


import requests
import os
import time
import json


import awkward as ak
import uproot
import vector
vector.register_awkward()


</code></pre>
<pre><code>Matplotlib is building the font cache; this may take a moment.
</code></pre>
<p>We will use the <strong>dpoa_workshop_utilities</strong> module to help you access the datasets. The functions it contains are:</p>
<p>The <code>nanoaod_filenames</code> is a dictionary with the urls to the file indexes of the root files for every dataset that we will use in the analysis.</p>
<p>The <code>pretty_print(fields, fmt='40s', require=None, ignore=None)</code> function allows you to print subsets of keys based on strings that you require or ignore. It will also format that output based on how many characters you want in a column (you are limited to 80 characters per line).</p>
<p>The <code>build_lumi_mask(lumifile, tree, verbose=False)</code> function helps you mask (select) the data that's collected from collisions.</p>
<pre><code class="language-python">#-------------------------------

import dpoa_workshop
from dpoa_workshop import (
    nanoaod_filenames,
    get_files_for_dataset,
    pretty_print,
    build_lumi_mask
)
#-------------------------------------------
</code></pre>
<p>In the drafts related to the papers, the datasets used from 2016 are listed along with their run periods and corresponding luminosities. However, one must be careful with these values, because not all periods are available and the data format differs from the one originally used, as previously noted.”</p>
<pre><code class="language-python">from IPython.display import Image, display

display(Image(filename=&quot;dataset_2016.png&quot;))

</code></pre>
<p><img alt="png" src="../output_9_0.png" /></p>
<pre><code class="language-python">
display(Image(filename=&quot;MC_data.png&quot;))

</code></pre>
<p><img alt="png" src="../output_10_0.png" /></p>
<h1 id="building-the-ntuple-file-index">Building the Ntuple File Index</h1>
<p>CMS Open Data provides <strong>file index text files</strong> (<code>file_index.txt</code>) for each dataset.<br />
These contain the actual XRootD paths to the NanoAOD <code>.root</code> files, along with metadata such as the number of events per file. Example line:</p>
<p>root://eospublic.cern.ch//eos/opendata/cms/mc/.../nano_1.root nevts=58293</p>
<p>The objective is to collect file paths from multiple URLs, organize them by dataset, and store them in a JSON file, while handling possible download errors so the program keeps running.</p>
<h3 id="to-streamline-the-workflow">To streamline the workflow:</h3>
<ul>
<li>We define a function <code>download_files(url)</code> that fetches each <code>file_index.txt</code> via HTTP and extracts only the ROOT file paths.  </li>
<li>We loop over all entries in <code>nanoaod_filenames</code> (the dictionary we built earlier) and collect the full list of ROOT files per dataset.  </li>
<li>The result is stored in a new dictionary <code>ntuples</code>, which maps <em>dataset -- list of ROOT file paths</em>.  </li>
<li>Finally, we save this as a JSON file (<code>ntuples.json</code>) for later reuse</li>
</ul>
<pre><code class="language-python">def download_files(url):
    r = requests.get(url)
    lines = [ln.strip() for ln in r.text.splitlines() if ln.strip()]

    paths = [ln.split()[0] for ln in lines]
    return paths

ntuples = {}

for dataset, urls in nanoaod_filenames.items():
    all_paths = []
    for url in urls:
        try:
            all_paths.extend(download_files(url))
        except Exception as e:
            print(f&quot;[warn] {dataset} {url}--{e}&quot;)
    ntuples[dataset] = all_paths

with open(&quot;ntuples.json&quot;, &quot;w&quot;) as f:
    json.dump(ntuples, f, indent=2)

print(&quot;ntuples.json :&quot;, list(ntuples.keys()))

</code></pre>
<pre><code>ntuples.json : ['met', 'SingleMuon', 'SingleElectron', 'ttbar-semileptonic', 'ttbar-hadronic', 't-channel-top', 'ttW', 'WJets-HT400to600', 'DYJets-Zpt200', 'WW', 'ZZ', 'Zvv']
</code></pre>
<p>And we will download important files like the luminosity file.</p>
<pre><code class="language-python">!wget https://opendata.cern.ch/record/14220/files/Cert_271036-284044_13TeV_Legacy2016_Collisions16_JSON.txt

</code></pre>
<pre><code>--2025-11-05 20:43:37--  https://opendata.cern.ch/record/14220/files/Cert_271036-284044_13TeV_Legacy2016_Collisions16_JSON.txt
Resolving opendata.cern.ch (opendata.cern.ch)... 137.138.6.31, 2001:1458:201:8b::100:1c8
Connecting to opendata.cern.ch (opendata.cern.ch)|137.138.6.31|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 11686 (11K) [text/plain]
Saving to: ‘Cert_271036-284044_13TeV_Legacy2016_Collisions16_JSON.txt’

Cert_271036-284044_ 100%[===================&gt;]  11.41K  --.-KB/s    in 0.001s

2025-11-05 20:43:38 (10.2 MB/s) - ‘Cert_271036-284044_13TeV_Legacy2016_Collisions16_JSON.txt’ saved [11686/11686]
</code></pre>
<p>Complete dictionary, in case it's possible to add all the events but it hasn't been found or verified yet...</p>
<pre><code class="language-python">    # --- Cross sections in pb de todo los dataset del paper ---

XSEC2_PB = {
    # --- TOP QUARK ---
    &quot;ttbar-semileptonic&quot;: 364.35,  
    &quot;t-channel-top&quot;: 136.02,       # ST t-channel top
    &quot;t-channel-antitop&quot;: 80.95,    # ST t-channel antitop
    &quot;tW-top&quot;: 35.85,               # ST tW top 

    # --- Rare Top ---
    &quot;ttW&quot;: 0.2043,  #  to TTWJetsToLNu
    &quot;ttZ&quot;: 0.2529,  # to TTZToLLNuNu

    # --- WJETS (HT Binned) ---

    &quot;WJets-HT70to100&quot;:    1372.0,
    &quot;WJets-HT100to200&quot;:   1345.0, # (Revisa este valor, parece alto para ser binned, quizás es LO)
    &quot;WJets-HT200to400&quot;:   359.7,  
    &quot;WJets-HT400to600&quot;:   48.91,  
    &quot;WJets-HT600to800&quot;:   12.05,
    &quot;WJets-HT800to1200&quot;:  5.501,  
    &quot;WJets-HT1200to2500&quot;: 1.329,  
    &quot;WJets-HT2500toInf&quot;:  0.0322,

    # --- DRELL-YAN (DY) ---
    &quot;DYJets-HT100to200&quot;: 147.40,
    &quot;DYJets-HT200to400&quot;: 40.99,
    &quot;DYJets-HT400to600&quot;: 5.678,

    # --- DIBOSON ---
    &quot;WW&quot;: 118.7, #   sumados dan aprox esto
    &quot;ZZ&quot;: 16.6,  # 
    &quot;WZ&quot;: 47.13  
}
</code></pre>
<p>until while these datasets are being used</p>
<pre><code class="language-python">    XSEC_PB = {
    # --- Top Quark ---
    &quot;ttbar-semileptonic&quot;: 364.35,   
    &quot;ttbar-hadronic&quot;:     377.96,  
    &quot;t-channel-top&quot;:      136.02,   
    &quot;ttW&quot;:                0.2043,   

    # --- WJets ---
    &quot;WJets-HT400to600&quot;:   48.91, 

    # --- Electroweak / Bosons ---
    &quot;DYJets-Zpt200&quot;:      1.27,     
    &quot;WW&quot;:                 118.7,    
    &quot;ZZ&quot;:                 16.6,     
    &quot;Zvv&quot;:                77.3,     
}

</code></pre>
<hr />
<p>This function builds the fileset used by the analysis. It reads the JSON inventory of ntuples, identifies which samples are data or MC, applies an optional file limit for fast debugging, and attaches minimal metadata such as the cross section and number of files. The output is a clean, ready-to-use dictionary that tells the processor exactly which datasets to run over and how they should be treated.</p>
<pre><code class="language-python">def construct_fileset(ntuples_json=&quot;ntuples.json&quot;, limit=None, verbose=True):
    &quot;&quot;&quot;
    Parses the input JSON inventory and assigns metadata (xsec, is_data).

    Args:
        ntuples_json (str): Path to the JSON file containing the file lists.
        limit (int or None): Max number of files to load per process. 
                             Useful for quick debugging (e.g., limit=1).
                             If None, loads all files (production mode).
        verbose (bool): If True, prints a summary table of loaded samples.

    Returns:
        dict: A dictionary structured for the processor (Coffea/UpRoot).
    &quot;&quot;&quot;

    # Load the file manifest
    with open(ntuples_json) as f:
        info = json.load(f)

    fileset = {}

    if verbose:
        print(f&quot;\n{'Process Name':30} {'Type':&gt;6} {'N Files':&gt;10} {'XSEC [pb]':&gt;12}&quot;)
        print(&quot;-&quot; * 65)

    # Iterate over each process found in the JSON
    for process_name, file_list in info.items():

        # --- A. APPLY LIMIT (DEBUG MODE) ---
        # Slicing handles None gracefully, but explicit check is clearer for readers
        if limit is not None:
            files_to_use = file_list[:limit]
        else:
            files_to_use = file_list

        # --- B. IDENTIFY TYPE (DATA vs MC) ---
        # Logic: If process exists in the Cross-Section table, treat as Simulation (MC).
        # Otherwise, treat as Real Data.
        if process_name in XSEC_PB:
            is_data = False
            xsec_value = XSEC_PB[process_name]
            proc_type = &quot;MC&quot;
        else:
            is_data = True
            xsec_value = None  # Real data has no theoretical xsec here
            proc_type = &quot;DATA&quot;

        # --- C. BUILD DICTIONARY ---
        # Minimal metadata structure to keep it lightweight
        fileset[process_name] = {
            &quot;files&quot;: files_to_use,
            &quot;metadata&quot;: {
                &quot;is_data&quot;: is_data,
                &quot;xsec&quot;: xsec_value,
                &quot;n_files_loaded&quot;: len(files_to_use)
            }
        }

        # --- D. LOGGING ---
        if verbose:
            xsec_str = f&quot;{xsec_value:.2f}&quot; if xsec_value else &quot;-&quot;
            print(f&quot;{process_name:30} {proc_type:&gt;6} {len(files_to_use):&gt;10} {xsec_str:&gt;12}&quot;)

    if verbose: 
        print(&quot;-&quot; * 65)
        print(f&quot; Fileset construction complete. Loaded {len(fileset)} processes.&quot;)

    return fileset
</code></pre>
<p>This line initializes the full list of datasets for the analysis. It loads all ntuples defined in <em>ntuples.json</em> (since <code>limit=None</code>) and prints a summary of the samples. The resulting <code>fileset</code> becomes the central input that tells the processor which data and MC files to process.</p>
<pre><code class="language-python">fileset = construct_fileset(
    ntuples_json=&quot;ntuples.json&quot;,
    limit=None,      
    verbose=True
)
</code></pre>
<pre><code>Process Name                     Type    N Files    XSEC [pb]
-----------------------------------------------------------------
met                              DATA         32            -
SingleMuon                       DATA         82            -
SingleElectron                   DATA         80            -
ttbar-semileptonic                 MC        138       364.35
ttbar-hadronic                     MC        146       377.96
t-channel-top                      MC         25       136.02
ttW                                MC         12         0.20
WJets-HT400to600                   MC         11        48.91
DYJets-Zpt200                      MC         10         1.27
WW                                 MC         41       118.70
ZZ                                 MC         17        16.60
Zvv                                MC         14        77.30
-----------------------------------------------------------------
 Fileset construction complete. Loaded 12 processes.
</code></pre>
<p>Before running a massive analysis loop (which might take hours), a physicist always opens one single file first. We call this Exploratory Data Analysis (EDA). You need to verify:</p>
<p>1.Are the files actually there?</p>
<p>2.What are the variable names? (Is it Muon_pt or Muon_pT? Case matters!)</p>
<p>3.What Triggers (HLT) are available?</p>
<p>Here is the code organized as a clear "Exploratory Phase" for students.</p>
<p>Why do we do this? We are about to treat the data as a "black box" in the processing loop. But we need to verify the inputs first. We use uproot, which is a Python library that allows us to read CERN ROOT files directly, without needing C++.</p>
<pre><code class="language-python">dataset = &quot;SingleMuon&quot;

for i, fpath in enumerate(fileset[dataset][&quot;files&quot;][:10]):
    print(f&quot;{i+1:2d}. {fpath}&quot;)

</code></pre>
<pre><code> 1. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/120000/61FC1E38-F75C-6B44-AD19-A9894155874E.root
 2. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/1210000/576759DA-4A35-534B-B926-2A9E4A5A7268.root
 3. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/0107961B-4308-F845-8F96-E14622BBA484.root
 4. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/0DEE1709-0416-F24B-ACB2-C68997CB6465.root
 5. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/1C08614E-0C0E-6044-966A-CAF630CAEF8F.root
 6. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/1D87B4FB-E31C-9F43-AC21-C32469DE9FC6.root
 7. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/1EB443F2-1230-8042-B8AE-FD50329CA59B.root
 8. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/2045F967-9F0A-7C46-9946-787B27D56E88.root
 9. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/236A04EE-C105-D947-8A2E-F8CC6731644F.root
10. root://eospublic.cern.ch//eos/opendata/cms/Run2016H/SingleMuon/NANOAOD/UL2016_MiniAODv2_NanoAODv9-v1/130000/370BE877-DA24-DB41-A875-07A86EAB6852.root
</code></pre>
<pre><code class="language-python">#import uproot

f = uproot.open(fileset[&quot;SingleMuon&quot;][&quot;files&quot;][0])
events = f[&quot;Events&quot;]
for name in events.keys():
    if &quot;Muon&quot; in name or &quot;Electron&quot; in name or &quot;Jet&quot; in name or &quot;MET&quot; in name:
        print(name)

</code></pre>
<pre><code>CaloMET_phi
CaloMET_pt
CaloMET_sumEt
ChsMET_phi
ChsMET_pt
ChsMET_sumEt
nCorrT1METJet
CorrT1METJet_area
CorrT1METJet_eta
CorrT1METJet_muonSubtrFactor
CorrT1METJet_phi
CorrT1METJet_rawPt
DeepMETResolutionTune_phi
DeepMETResolutionTune_pt
DeepMETResponseTune_phi
DeepMETResponseTune_pt
nElectron
Electron_dEscaleDown
Electron_dEscaleUp
Electron_dEsigmaDown
Electron_dEsigmaUp
Electron_deltaEtaSC
Electron_dr03EcalRecHitSumEt
Electron_dr03HcalDepth1TowerSumEt
Electron_dr03TkSumPt
Electron_dr03TkSumPtHEEP
Electron_dxy
Electron_dxyErr
Electron_dz
Electron_dzErr
Electron_eCorr
Electron_eInvMinusPInv
Electron_energyErr
Electron_eta
Electron_hoe
Electron_ip3d
Electron_jetPtRelv2
Electron_jetRelIso
Electron_mass
Electron_miniPFRelIso_all
Electron_miniPFRelIso_chg
Electron_mvaFall17V2Iso
Electron_mvaFall17V2noIso
Electron_pfRelIso03_all
Electron_pfRelIso03_chg
Electron_phi
Electron_pt
Electron_r9
Electron_scEtOverPt
Electron_sieie
Electron_sip3d
Electron_mvaTTH
Electron_charge
Electron_cutBased
Electron_jetIdx
Electron_pdgId
Electron_photonIdx
Electron_tightCharge
Electron_vidNestedWPBitmap
Electron_vidNestedWPBitmapHEEP
Electron_convVeto
Electron_cutBased_HEEP
Electron_isPFcand
Electron_jetNDauCharged
Electron_lostHits
Electron_mvaFall17V2Iso_WP80
Electron_mvaFall17V2Iso_WP90
Electron_mvaFall17V2Iso_WPL
Electron_mvaFall17V2noIso_WP80
Electron_mvaFall17V2noIso_WP90
Electron_mvaFall17V2noIso_WPL
Electron_seedGain
nFatJet
FatJet_area
FatJet_btagCSVV2
FatJet_btagDDBvLV2
FatJet_btagDDCvBV2
FatJet_btagDDCvLV2
FatJet_btagDeepB
FatJet_btagHbb
FatJet_deepTagMD_H4qvsQCD
FatJet_deepTagMD_HbbvsQCD
FatJet_deepTagMD_TvsQCD
FatJet_deepTagMD_WvsQCD
FatJet_deepTagMD_ZHbbvsQCD
FatJet_deepTagMD_ZHccvsQCD
FatJet_deepTagMD_ZbbvsQCD
FatJet_deepTagMD_ZvsQCD
FatJet_deepTagMD_bbvsLight
FatJet_deepTagMD_ccvsLight
FatJet_deepTag_H
FatJet_deepTag_QCD
FatJet_deepTag_QCDothers
FatJet_deepTag_TvsQCD
FatJet_deepTag_WvsQCD
FatJet_deepTag_ZvsQCD
FatJet_eta
FatJet_mass
FatJet_msoftdrop
FatJet_n2b1
FatJet_n3b1
FatJet_particleNetMD_QCD
FatJet_particleNetMD_Xbb
FatJet_particleNetMD_Xcc
FatJet_particleNetMD_Xqq
FatJet_particleNet_H4qvsQCD
FatJet_particleNet_HbbvsQCD
FatJet_particleNet_HccvsQCD
FatJet_particleNet_QCD
FatJet_particleNet_TvsQCD
FatJet_particleNet_WvsQCD
FatJet_particleNet_ZvsQCD
FatJet_particleNet_mass
FatJet_phi
FatJet_pt
FatJet_rawFactor
FatJet_tau1
FatJet_tau2
FatJet_tau3
FatJet_tau4
FatJet_lsf3
FatJet_jetId
FatJet_subJetIdx1
FatJet_subJetIdx2
FatJet_electronIdx3SJ
FatJet_muonIdx3SJ
FatJet_nConstituents
nJet
Jet_area
Jet_btagCSVV2
Jet_btagDeepB
Jet_btagDeepCvB
Jet_btagDeepCvL
Jet_btagDeepFlavB
Jet_btagDeepFlavCvB
Jet_btagDeepFlavCvL
Jet_btagDeepFlavQG
Jet_chEmEF
Jet_chFPV0EF
Jet_chHEF
Jet_eta
Jet_hfsigmaEtaEta
Jet_hfsigmaPhiPhi
Jet_mass
Jet_muEF
Jet_muonSubtrFactor
Jet_neEmEF
Jet_neHEF
Jet_phi
Jet_pt
Jet_puIdDisc
Jet_qgl
Jet_rawFactor
Jet_bRegCorr
Jet_bRegRes
Jet_cRegCorr
Jet_cRegRes
Jet_electronIdx1
Jet_electronIdx2
Jet_hfadjacentEtaStripsSize
Jet_hfcentralEtaStripSize
Jet_jetId
Jet_muonIdx1
Jet_muonIdx2
Jet_nElectrons
Jet_nMuons
Jet_puId
Jet_nConstituents
L1PreFiringWeight_Muon_Nom
L1PreFiringWeight_Muon_StatDn
L1PreFiringWeight_Muon_StatUp
L1PreFiringWeight_Muon_SystDn
L1PreFiringWeight_Muon_SystUp
nLowPtElectron
LowPtElectron_ID
LowPtElectron_convVtxRadius
LowPtElectron_deltaEtaSC
LowPtElectron_dxy
LowPtElectron_dxyErr
LowPtElectron_dz
LowPtElectron_dzErr
LowPtElectron_eInvMinusPInv
LowPtElectron_embeddedID
LowPtElectron_energyErr
LowPtElectron_eta
LowPtElectron_hoe
LowPtElectron_mass
LowPtElectron_miniPFRelIso_all
LowPtElectron_miniPFRelIso_chg
LowPtElectron_phi
LowPtElectron_pt
LowPtElectron_ptbiased
LowPtElectron_r9
LowPtElectron_scEtOverPt
LowPtElectron_sieie
LowPtElectron_unbiased
LowPtElectron_charge
LowPtElectron_convWP
LowPtElectron_pdgId
LowPtElectron_convVeto
LowPtElectron_lostHits
MET_MetUnclustEnUpDeltaX
MET_MetUnclustEnUpDeltaY
MET_covXX
MET_covXY
MET_covYY
MET_phi
MET_pt
MET_significance
MET_sumEt
MET_sumPtUnclustered
nMuon
Muon_dxy
Muon_dxyErr
Muon_dxybs
Muon_dz
Muon_dzErr
Muon_eta
Muon_ip3d
Muon_jetPtRelv2
Muon_jetRelIso
Muon_mass
Muon_miniPFRelIso_all
Muon_miniPFRelIso_chg
Muon_pfRelIso03_all
Muon_pfRelIso03_chg
Muon_pfRelIso04_all
Muon_phi
Muon_pt
Muon_ptErr
Muon_segmentComp
Muon_sip3d
Muon_softMva
Muon_tkRelIso
Muon_tunepRelPt
Muon_mvaLowPt
Muon_mvaTTH
Muon_charge
Muon_jetIdx
Muon_nStations
Muon_nTrackerLayers
Muon_pdgId
Muon_tightCharge
Muon_fsrPhotonIdx
Muon_highPtId
Muon_highPurity
Muon_inTimeMuon
Muon_isGlobal
Muon_isPFcand
Muon_isStandalone
Muon_isTracker
Muon_jetNDauCharged
Muon_looseId
Muon_mediumId
Muon_mediumPromptId
Muon_miniIsoId
Muon_multiIsoId
Muon_mvaId
Muon_mvaLowPtId
Muon_pfIsoId
Muon_puppiIsoId
Muon_softId
Muon_softMvaId
Muon_tightId
Muon_tkIsoId
Muon_triggerIdLoose
PuppiMET_phi
PuppiMET_phiJERDown
PuppiMET_phiJERUp
PuppiMET_phiJESDown
PuppiMET_phiJESUp
PuppiMET_phiUnclusteredDown
PuppiMET_phiUnclusteredUp
PuppiMET_pt
PuppiMET_ptJERDown
PuppiMET_ptJERUp
PuppiMET_ptJESDown
PuppiMET_ptJESUp
PuppiMET_ptUnclusteredDown
PuppiMET_ptUnclusteredUp
PuppiMET_sumEt
RawMET_phi
RawMET_pt
RawMET_sumEt
RawPuppiMET_phi
RawPuppiMET_pt
RawPuppiMET_sumEt
nSoftActivityJet
SoftActivityJet_eta
SoftActivityJet_phi
SoftActivityJet_pt
SoftActivityJetHT
SoftActivityJetHT10
SoftActivityJetHT2
SoftActivityJetHT5
SoftActivityJetNjets10
SoftActivityJetNjets2
SoftActivityJetNjets5
nSubJet
SubJet_btagCSVV2
SubJet_btagDeepB
SubJet_eta
SubJet_mass
SubJet_n2b1
SubJet_n3b1
SubJet_phi
SubJet_pt
SubJet_rawFactor
SubJet_tau1
SubJet_tau2
SubJet_tau3
SubJet_tau4
TkMET_phi
TkMET_pt
TkMET_sumEt
Electron_cleanmask
Jet_cleanmask
Muon_cleanmask
L1_CastorHaloMuon
L1_CastorHaloMuon_BptxAND
L1_CastorHighJet_BptxAND
L1_CastorMediumJet_BptxAND
L1_DoubleJet12_ForwardBackward
L1_DoubleJet16_ForwardBackward
L1_DoubleJet30_Mj30j30_400_Mu10
L1_DoubleJet30_Mj30j30_400_Mu6
L1_DoubleJet8_ForwardBackward
L1_DoubleJetC100
L1_DoubleJetC112
L1_DoubleJetC120
L1_DoubleJetC40
L1_DoubleJetC50
L1_DoubleJetC60
L1_DoubleJetC60_ETM60
L1_DoubleJetC80
L1_DoubleJet_100_30_Mj30j30_620
L1_DoubleJet_90_30_Mj30j30_620
L1_ETM75_Jet60_dPhi_Min0p4
L1_Jet32_DoubleMu_10_0_dPhi_Jet_Mu0_Max0p4_dPhi_Mu_Mu_Min1p0
L1_Jet32_Mu0_EG10_dPhi_Jet_Mu_Max0p4_dPhi_Mu_EG_Min1p0
L1_Mu3_JetC120
L1_Mu3_JetC120_dEta_Max0p4_dPhi_Max0p4
L1_Mu3_JetC16
L1_Mu3_JetC16_dEta_Max0p4_dPhi_Max0p4
L1_Mu3_JetC60
L1_Mu3_JetC60_dEta_Max0p4_dPhi_Max0p4
L1_QuadJetC36_Tau52
L1_QuadJetC40
L1_QuadJetC50
L1_QuadJetC60
L1_SingleJet12
L1_SingleJet120
L1_SingleJet12_BptxAND
L1_SingleJet140
L1_SingleJet150
L1_SingleJet16
L1_SingleJet160
L1_SingleJet170
L1_SingleJet180
L1_SingleJet20
L1_SingleJet200
L1_SingleJet35
L1_SingleJet4
L1_SingleJet60
L1_SingleJet8
L1_SingleJet8_BptxAND
L1_SingleJet90
L1_SingleJetC20_NotBptxOR
L1_SingleJetC20_NotBptxOR_3BX
L1_SingleJetC40_NotBptxOR_3BX
L1_SingleJetC40_NotBptxOR_5BX
L1_TripleJet_84_68_48_VBF
L1_TripleJet_88_72_56_VBF
L1_TripleJet_92_76_64_VBF
Flag_BadPFMuonFilter
Flag_BadPFMuonDzFilter
Flag_BadPFMuonSummer16Filter
Flag_METFilters
Flag_BadPFMuonFilter_pRECO
Flag_BadPFMuonSummer16Filter_pRECO
Flag_METFilters_pRECO
HLT_AK8PFJet360_TrimMass30
HLT_AK8PFJet400_TrimMass30
HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p20
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p087
HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p087
HLT_AK8DiPFJet300_200_TrimMass30
HLT_AK8DiPFJet280_200_TrimMass30
HLT_AK8DiPFJet250_200_TrimMass30
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p20
HLT_AK8DiPFJet250_200_TrimMass30_BTagCSV_p20
HLT_CaloJet500_NoJetID
HLT_Ele27_WPTight_Gsf_L1JetTauSeeded
HLT_Ele45_CaloIdVT_GsfTrkIdT_PFJet200_PFJet50
HLT_IsoMu16_eta2p1_MET30
HLT_IsoMu16_eta2p1_MET30_LooseIsoPFTau50_Trk30_eta2p1
HLT_JetE30_NoBPTX3BX
HLT_JetE30_NoBPTX
HLT_JetE50_NoBPTX3BX
HLT_JetE70_NoBPTX3BX
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET90
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET110
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET120
HLT_Mu30_eta2p1_PFJet150_PFJet50
HLT_Mu40_eta2p1_PFJet200_PFJet50
HLT_Mu28NoFiltersNoVtx_DisplacedJet40_Loose
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Tight
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Loose
HLT_Mu38NoFiltersNoVtx_DisplacedJet60_Loose
HLT_Mu28NoFiltersNoVtx_CentralCaloJet40
HLT_PFHT300_PFMET110
HLT_PFHT550_4JetPt50
HLT_PFHT650_4JetPt50
HLT_PFHT750_4JetPt70
HLT_PFHT750_4JetPt80
HLT_PFHT800_4JetPt50
HLT_PFHT850_4JetPt50
HLT_PFJet15_NoCaloMatched
HLT_PFJet25_NoCaloMatched
HLT_DiPFJet15_NoCaloMatched
HLT_DiPFJet25_NoCaloMatched
HLT_DiPFJet15_FBEta3_NoCaloMatched
HLT_DiPFJet25_FBEta3_NoCaloMatched
HLT_DiPFJetAve15_HFJEC
HLT_DiPFJetAve25_HFJEC
HLT_DiPFJetAve35_HFJEC
HLT_AK8PFJet40
HLT_AK8PFJet60
HLT_AK8PFJet80
HLT_AK8PFJet140
HLT_AK8PFJet200
HLT_AK8PFJet260
HLT_AK8PFJet320
HLT_AK8PFJet400
HLT_AK8PFJet450
HLT_AK8PFJet500
HLT_PFJet40
HLT_PFJet60
HLT_PFJet80
HLT_PFJet140
HLT_PFJet200
HLT_PFJet260
HLT_PFJet320
HLT_PFJet400
HLT_PFJet450
HLT_PFJet500
HLT_DiPFJetAve40
HLT_DiPFJetAve60
HLT_DiPFJetAve80
HLT_DiPFJetAve140
HLT_DiPFJetAve200
HLT_DiPFJetAve260
HLT_DiPFJetAve320
HLT_DiPFJetAve400
HLT_DiPFJetAve500
HLT_DiPFJetAve60_HFJEC
HLT_DiPFJetAve80_HFJEC
HLT_DiPFJetAve100_HFJEC
HLT_DiPFJetAve160_HFJEC
HLT_DiPFJetAve220_HFJEC
HLT_DiPFJetAve300_HFJEC
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu140
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu80
HLT_DiCentralPFJet170
HLT_SingleCentralPFJet170_CFMax0p1
HLT_DiCentralPFJet170_CFMax0p1
HLT_DiCentralPFJet330_CFMax0p5
HLT_DiCentralPFJet430
HLT_DiJetVBF_PassThrough
HLT_DiJetVBFMu_PassThrough
HLT_PFHT200_DiPFJetAve90_PFAlphaT0p63
HLT_PFHT250_DiPFJetAve90_PFAlphaT0p58
HLT_PFHT300_DiPFJetAve90_PFAlphaT0p54
HLT_PFHT350_DiPFJetAve90_PFAlphaT0p53
HLT_PFHT400_DiPFJetAve90_PFAlphaT0p52
HLT_MET60_IsoTrk35_Loose
HLT_MET75_IsoTrk50
HLT_MET90_IsoTrk50
HLT_PFMET170_NotCleaned
HLT_PFMET170_HBHECleaned
HLT_PFMET170_BeamHaloCleaned
HLT_PFMET170_HBHE_BeamHaloCleaned
HLT_PFMETTypeOne190_HBHE_BeamHaloCleaned
HLT_PFMET110_PFMHT110_IDTight
HLT_PFMET120_PFMHT120_IDTight
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight_BTagCSV_p067
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq200
HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq460
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq240
HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq500
HLT_QuadPFJet_VBF
HLT_L1_TripleJet_VBF
HLT_QuadJet45_TripleBTagCSV_p087
HLT_QuadJet45_DoubleBTagCSV_p087
HLT_DoubleJet90_Double30_TripleBTagCSV_p087
HLT_DoubleJet90_Double30_DoubleBTagCSV_p087
HLT_DoubleJetsC100_DoubleBTagCSV_p026_DoublePFJetsC160
HLT_DoubleJetsC100_DoubleBTagCSV_p014_DoublePFJetsC100MaxDeta1p6
HLT_DoubleJetsC112_DoubleBTagCSV_p026_DoublePFJetsC172
HLT_DoubleJetsC112_DoubleBTagCSV_p014_DoublePFJetsC112MaxDeta1p6
HLT_DoubleJetsC100_SingleBTagCSV_p026
HLT_DoubleJetsC100_SingleBTagCSV_p014
HLT_DoubleJetsC100_SingleBTagCSV_p026_SinglePFJetC350
HLT_DoubleJetsC100_SingleBTagCSV_p014_SinglePFJetC350
HLT_Photon135_PFMET100
HLT_Photon22_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon36_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon50_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon75_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon90_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon120_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Ele8_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele12_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele17_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele23_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_BTagMu_DiJet20_Mu5
HLT_BTagMu_DiJet40_Mu5
HLT_BTagMu_DiJet70_Mu5
HLT_BTagMu_DiJet110_Mu5
HLT_BTagMu_DiJet170_Mu5
HLT_BTagMu_Jet300_Mu5
HLT_BTagMu_AK8Jet300_Mu5
HLT_Ele23_Ele12_CaloIdL_TrackIdL_IsoVL_DZ_L1JetTauSeeded
HLT_Mu6_PFHT200_PFMET100
HLT_PFHT650_WideJetMJJ900DEtaJJ1p5
HLT_PFHT650_WideJetMJJ950DEtaJJ1p5
HLT_Dimuon0_Jpsi_Muon
HLT_Dimuon0_Upsilon_Muon
HLT_QuadMuon0_Dimuon0_Jpsi
HLT_QuadMuon0_Dimuon0_Upsilon
HLT_Rsq0p02_MR400_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR450_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR500_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR550_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_VBF_DisplacedJet40_DisplacedTrack
HLT_VBF_DisplacedJet40_DisplacedTrack_2TrackIP2DSig5
HLT_VBF_DisplacedJet40_TightID_DisplacedTrack
HLT_VBF_DisplacedJet40_TightID_Hadronic
HLT_VBF_DisplacedJet40_VTightID_Hadronic
HLT_VBF_DisplacedJet40_VVTightID_Hadronic
HLT_VBF_DisplacedJet40_VTightID_DisplacedTrack
HLT_VBF_DisplacedJet40_VVTightID_DisplacedTrack
HLT_PFMETNoMu110_PFMHTNoMu110_IDTight
HLT_PFMETNoMu120_PFMHTNoMu120_IDTight
HLT_MonoCentralPFJet80_PFMETNoMu110_PFMHTNoMu110_IDTight
HLT_MonoCentralPFJet80_PFMETNoMu120_PFMHTNoMu120_IDTight
HLT_Mu10_CentralPFJet30_BTagCSV_p13
HLT_DoubleMu3_PFMET50
HLT_Ele10_CaloIdM_TrackIdM_CentralPFJet30_BTagCSV_p13
HLT_Ele15_IsoVVVL_PFHT400_PFMET50
HLT_Mu8_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT300_PFMETNoMu60
HLT_Mu10_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT350_PFMETNoMu60
HLT_Mu15_IsoVVVL_PFHT400_PFMET50
HLT_Mu3_PFJet40
HLT_Ele8_CaloIdM_TrackIdM_PFJet30
HLT_Ele12_CaloIdM_TrackIdM_PFJet30
HLT_Ele17_CaloIdM_TrackIdM_PFJet30
HLT_Ele23_CaloIdM_TrackIdM_PFJet30
HLT_Ele50_CaloIdVT_GsfTrkIdT_PFJet165
HLT_PFHT400_SixJet30_DoubleBTagCSV_p056
HLT_PFHT450_SixJet40_BTagCSV_p056
HLT_PFHT400_SixJet30
HLT_PFHT450_SixJet40
HLT_MET200
HLT_AK4CaloJet30
HLT_AK4CaloJet40
HLT_AK4CaloJet50
HLT_AK4CaloJet80
HLT_AK4CaloJet100
HLT_AK4PFJet30
HLT_AK4PFJet50
HLT_AK4PFJet80
HLT_AK4PFJet100
HLT_MET250
HLT_MET300
HLT_MET600
HLT_MET700
HLT_PFMET300
HLT_PFMET400
HLT_PFMET500
HLT_PFMET600
</code></pre>
<pre><code class="language-python">for b in events.keys():
    if b.startswith(&quot;HLT_&quot;):
        print(b)

</code></pre>
<pre><code>HLT_AK8PFJet360_TrimMass30
HLT_AK8PFJet400_TrimMass30
HLT_AK8PFHT750_TrimMass50
HLT_AK8PFHT800_TrimMass50
HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p20
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p087
HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p087
HLT_AK8DiPFJet300_200_TrimMass30
HLT_AK8PFHT700_TrimR0p1PT0p03Mass50
HLT_AK8PFHT650_TrimR0p1PT0p03Mass50
HLT_AK8PFHT600_TrimR0p1PT0p03Mass50_BTagCSV_p20
HLT_AK8DiPFJet280_200_TrimMass30
HLT_AK8DiPFJet250_200_TrimMass30
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p20
HLT_AK8DiPFJet250_200_TrimMass30_BTagCSV_p20
HLT_CaloJet500_NoJetID
HLT_Dimuon13_PsiPrime
HLT_Dimuon13_Upsilon
HLT_Dimuon20_Jpsi
HLT_DoubleEle24_22_eta2p1_WPLoose_Gsf
HLT_DoubleEle33_CaloIdL
HLT_DoubleEle33_CaloIdL_MW
HLT_DoubleEle33_CaloIdL_GsfTrkIdVL_MW
HLT_DoubleMediumCombinedIsoPFTau35_Trk1_eta2p1_Reg
HLT_DoubleTightCombinedIsoPFTau35_Trk1_eta2p1_Reg
HLT_DoubleMediumCombinedIsoPFTau40_Trk1_eta2p1_Reg
HLT_DoubleTightCombinedIsoPFTau40_Trk1_eta2p1_Reg
HLT_DoubleMediumCombinedIsoPFTau40_Trk1_eta2p1
HLT_DoubleTightCombinedIsoPFTau40_Trk1_eta2p1
HLT_DoubleEle37_Ele27_CaloIdL_GsfTrkIdVL
HLT_DoubleMu33NoFiltersNoVtx
HLT_DoubleMu38NoFiltersNoVtx
HLT_DoubleMu23NoFiltersNoVtxDisplaced
HLT_DoubleMu28NoFiltersNoVtxDisplaced
HLT_DoubleMu0
HLT_DoubleMu4_3_Bs
HLT_DoubleMu4_3_Jpsi_Displaced
HLT_DoubleMu4_JpsiTrk_Displaced
HLT_DoubleMu4_LowMassNonResonantTrk_Displaced
HLT_DoubleMu3_Trk_Tau3mu
HLT_DoubleMu4_PsiPrimeTrk_Displaced
HLT_Mu7p5_L2Mu2_Jpsi
HLT_Mu7p5_L2Mu2_Upsilon
HLT_Mu7p5_Track2_Jpsi
HLT_Mu7p5_Track3p5_Jpsi
HLT_Mu7p5_Track7_Jpsi
HLT_Mu7p5_Track2_Upsilon
HLT_Mu7p5_Track3p5_Upsilon
HLT_Mu7p5_Track7_Upsilon
HLT_Dimuon0er16_Jpsi_NoOS_NoVertexing
HLT_Dimuon6_Jpsi_NoVertexing
HLT_DoublePhoton60
HLT_DoublePhoton85
HLT_Ele20_eta2p1_WPLoose_Gsf_LooseIsoPFTau28
HLT_Ele22_eta2p1_WPLoose_Gsf_LooseIsoPFTau29
HLT_Ele22_eta2p1_WPLoose_Gsf
HLT_Ele24_eta2p1_WPLoose_Gsf_LooseIsoPFTau30
HLT_Ele25_WPTight_Gsf
HLT_Ele25_eta2p1_WPTight_Gsf
HLT_Ele27_WPLoose_Gsf_WHbbBoost
HLT_Ele27_WPTight_Gsf
HLT_Ele27_WPTight_Gsf_L1JetTauSeeded
HLT_Ele27_eta2p1_WPLoose_Gsf
HLT_Ele27_eta2p1_WPTight_Gsf
HLT_Ele30_WPTight_Gsf
HLT_Ele30_eta2p1_WPTight_Gsf
HLT_Ele32_WPTight_Gsf
HLT_Ele32_eta2p1_WPTight_Gsf
HLT_Ele36_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_SingleL1
HLT_Ele45_CaloIdVT_GsfTrkIdT_PFJet200_PFJet50
HLT_Ele105_CaloIdVT_GsfTrkIdT
HLT_HT200
HLT_HT275
HLT_HT325
HLT_HT425
HLT_HT575
HLT_HT430to450
HLT_HT450to470
HLT_HT470to500
HLT_HT500to550
HLT_HT550to650
HLT_HT650
HLT_IsoMu16_eta2p1_MET30
HLT_IsoMu16_eta2p1_MET30_LooseIsoPFTau50_Trk30_eta2p1
HLT_DoubleIsoMu17_eta2p1_noDzCut
HLT_IsoMu19_eta2p1_LooseIsoPFTau20
HLT_IsoMu19_eta2p1_LooseIsoPFTau20_SingleL1
HLT_IsoMu19_eta2p1_MediumIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu19_eta2p1_LooseCombinedIsoPFTau20
HLT_IsoMu19_eta2p1_MediumCombinedIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu19_eta2p1_TightCombinedIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu21_eta2p1_MediumCombinedIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu21_eta2p1_TightCombinedIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu20
HLT_IsoMu21_eta2p1_LooseIsoPFTau20_SingleL1
HLT_IsoMu21_eta2p1_LooseIsoPFTau50_Trk30_eta2p1_SingleL1
HLT_IsoMu21_eta2p1_MediumIsoPFTau32_Trk1_eta2p1_Reg
HLT_IsoMu22
HLT_IsoMu22_eta2p1
HLT_IsoMu24
HLT_IsoMu24_eta2p1
HLT_IsoMu27
HLT_IsoTkMu20
HLT_IsoTkMu22
HLT_IsoTkMu22_eta2p1
HLT_IsoTkMu24
HLT_IsoTkMu24_eta2p1
HLT_IsoTkMu27
HLT_JetE30_NoBPTX3BX
HLT_JetE30_NoBPTX
HLT_JetE50_NoBPTX3BX
HLT_JetE70_NoBPTX3BX
HLT_L1SingleMu18
HLT_L2Mu10
HLT_L2DoubleMu23_NoVertex
HLT_L2DoubleMu28_NoVertex_2Cha_Angle2p5_Mass10
HLT_L2DoubleMu38_NoVertex_2Cha_Angle2p5_Mass10
HLT_L2Mu10_NoVertex_NoBPTX3BX
HLT_L2Mu10_NoVertex_NoBPTX
HLT_L2Mu45_NoVertex_3Sta_NoBPTX3BX
HLT_L2Mu40_NoVertex_3Sta_NoBPTX3BX
HLT_LooseIsoPFTau50_Trk30_eta2p1
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET90
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET110
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET120
HLT_PFTau120_eta2p1
HLT_PFTau140_eta2p1
HLT_VLooseIsoPFTau120_Trk50_eta2p1
HLT_VLooseIsoPFTau140_Trk50_eta2p1
HLT_Mu17_Mu8
HLT_Mu17_Mu8_DZ
HLT_Mu17_Mu8_SameSign
HLT_Mu17_Mu8_SameSign_DZ
HLT_Mu20_Mu10
HLT_Mu20_Mu10_DZ
HLT_Mu20_Mu10_SameSign
HLT_Mu20_Mu10_SameSign_DZ
HLT_Mu17_TkMu8_DZ
HLT_Mu17_TrkIsoVVL_Mu8_TrkIsoVVL
HLT_Mu17_TrkIsoVVL_Mu8_TrkIsoVVL_DZ
HLT_Mu17_TrkIsoVVL_TkMu8_TrkIsoVVL
HLT_Mu17_TrkIsoVVL_TkMu8_TrkIsoVVL_DZ
HLT_Mu25_TkMu0_dEta18_Onia
HLT_Mu27_TkMu8
HLT_Mu30_TkMu11
HLT_Mu30_eta2p1_PFJet150_PFJet50
HLT_Mu40_TkMu11
HLT_Mu40_eta2p1_PFJet200_PFJet50
HLT_Mu20
HLT_TkMu17
HLT_TkMu17_TrkIsoVVL_TkMu8_TrkIsoVVL
HLT_TkMu17_TrkIsoVVL_TkMu8_TrkIsoVVL_DZ
HLT_TkMu20
HLT_Mu24_eta2p1
HLT_TkMu24_eta2p1
HLT_Mu27
HLT_TkMu27
HLT_Mu45_eta2p1
HLT_Mu50
HLT_TkMu50
HLT_Mu38NoFiltersNoVtx_Photon38_CaloIdL
HLT_Mu42NoFiltersNoVtx_Photon42_CaloIdL
HLT_Mu28NoFiltersNoVtxDisplaced_Photon28_CaloIdL
HLT_Mu33NoFiltersNoVtxDisplaced_Photon33_CaloIdL
HLT_Mu23NoFiltersNoVtx_Photon23_CaloIdL
HLT_DoubleMu18NoFiltersNoVtx
HLT_Mu28NoFiltersNoVtx_DisplacedJet40_Loose
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Tight
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Loose
HLT_Mu38NoFiltersNoVtx_DisplacedJet60_Loose
HLT_Mu28NoFiltersNoVtx_CentralCaloJet40
HLT_PFHT300_PFMET110
HLT_PFHT550_4JetPt50
HLT_PFHT650_4JetPt50
HLT_PFHT750_4JetPt70
HLT_PFHT750_4JetPt80
HLT_PFHT800_4JetPt50
HLT_PFHT850_4JetPt50
HLT_PFJet15_NoCaloMatched
HLT_PFJet25_NoCaloMatched
HLT_DiPFJet15_NoCaloMatched
HLT_DiPFJet25_NoCaloMatched
HLT_DiPFJet15_FBEta3_NoCaloMatched
HLT_DiPFJet25_FBEta3_NoCaloMatched
HLT_DiPFJetAve15_HFJEC
HLT_DiPFJetAve25_HFJEC
HLT_DiPFJetAve35_HFJEC
HLT_AK8PFJet40
HLT_AK8PFJet60
HLT_AK8PFJet80
HLT_AK8PFJet140
HLT_AK8PFJet200
HLT_AK8PFJet260
HLT_AK8PFJet320
HLT_AK8PFJet400
HLT_AK8PFJet450
HLT_AK8PFJet500
HLT_PFJet40
HLT_PFJet60
HLT_PFJet80
HLT_PFJet140
HLT_PFJet200
HLT_PFJet260
HLT_PFJet320
HLT_PFJet400
HLT_PFJet450
HLT_PFJet500
HLT_DiPFJetAve40
HLT_DiPFJetAve60
HLT_DiPFJetAve80
HLT_DiPFJetAve140
HLT_DiPFJetAve200
HLT_DiPFJetAve260
HLT_DiPFJetAve320
HLT_DiPFJetAve400
HLT_DiPFJetAve500
HLT_DiPFJetAve60_HFJEC
HLT_DiPFJetAve80_HFJEC
HLT_DiPFJetAve100_HFJEC
HLT_DiPFJetAve160_HFJEC
HLT_DiPFJetAve220_HFJEC
HLT_DiPFJetAve300_HFJEC
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu140
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu80
HLT_DiCentralPFJet170
HLT_SingleCentralPFJet170_CFMax0p1
HLT_DiCentralPFJet170_CFMax0p1
HLT_DiCentralPFJet330_CFMax0p5
HLT_DiCentralPFJet430
HLT_DiJetVBF_PassThrough
HLT_DiJetVBFMu_PassThrough
HLT_PFHT125
HLT_PFHT200
HLT_PFHT250
HLT_PFHT300
HLT_PFHT350
HLT_PFHT400
HLT_PFHT475
HLT_PFHT600
HLT_PFHT650
HLT_PFHT900
HLT_PFHT200_PFAlphaT0p51
HLT_PFHT200_DiPFJetAve90_PFAlphaT0p63
HLT_PFHT250_DiPFJetAve90_PFAlphaT0p58
HLT_PFHT300_DiPFJetAve90_PFAlphaT0p54
HLT_PFHT350_DiPFJetAve90_PFAlphaT0p53
HLT_PFHT400_DiPFJetAve90_PFAlphaT0p52
HLT_MET60_IsoTrk35_Loose
HLT_MET75_IsoTrk50
HLT_MET90_IsoTrk50
HLT_PFMET170_NotCleaned
HLT_PFMET170_HBHECleaned
HLT_PFMET170_BeamHaloCleaned
HLT_PFMET170_HBHE_BeamHaloCleaned
HLT_PFMETTypeOne190_HBHE_BeamHaloCleaned
HLT_PFMET110_PFMHT110_IDTight
HLT_PFMET120_PFMHT120_IDTight
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight_BTagCSV_p067
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq200
HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq460
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq240
HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq500
HLT_QuadPFJet_VBF
HLT_L1_TripleJet_VBF
HLT_QuadJet45_TripleBTagCSV_p087
HLT_QuadJet45_DoubleBTagCSV_p087
HLT_DoubleJet90_Double30_TripleBTagCSV_p087
HLT_DoubleJet90_Double30_DoubleBTagCSV_p087
HLT_DoubleJetsC100_DoubleBTagCSV_p026_DoublePFJetsC160
HLT_DoubleJetsC100_DoubleBTagCSV_p014_DoublePFJetsC100MaxDeta1p6
HLT_DoubleJetsC112_DoubleBTagCSV_p026_DoublePFJetsC172
HLT_DoubleJetsC112_DoubleBTagCSV_p014_DoublePFJetsC112MaxDeta1p6
HLT_DoubleJetsC100_SingleBTagCSV_p026
HLT_DoubleJetsC100_SingleBTagCSV_p014
HLT_DoubleJetsC100_SingleBTagCSV_p026_SinglePFJetC350
HLT_DoubleJetsC100_SingleBTagCSV_p014_SinglePFJetC350
HLT_Photon135_PFMET100
HLT_Photon22_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon22_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Photon250_NoHE
HLT_Photon300_NoHE
HLT_Photon26_R9Id85_OR_CaloId24b40e_Iso50T80L_Photon16_AND_HE10_R9Id65_Eta2_Mass60
HLT_Photon36_R9Id85_OR_CaloId24b40e_Iso50T80L_Photon22_AND_HE10_R9Id65_Eta2_Mass15
HLT_Photon36_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon36_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Photon50_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon50_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Photon75_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon75_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Photon90_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon90_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Photon120_R9Id90_HE10_Iso40_EBOnly_PFMET40
HLT_Photon120_R9Id90_HE10_Iso40_EBOnly_VBF
HLT_Mu8_TrkIsoVVL
HLT_Mu17_TrkIsoVVL
HLT_Ele8_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele12_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele17_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_Ele23_CaloIdL_TrackIdL_IsoVL_PFJet30
HLT_BTagMu_DiJet20_Mu5
HLT_BTagMu_DiJet40_Mu5
HLT_BTagMu_DiJet70_Mu5
HLT_BTagMu_DiJet110_Mu5
HLT_BTagMu_DiJet170_Mu5
HLT_BTagMu_Jet300_Mu5
HLT_BTagMu_AK8Jet300_Mu5
HLT_Ele23_Ele12_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Ele23_Ele12_CaloIdL_TrackIdL_IsoVL_DZ_L1JetTauSeeded
HLT_Ele17_Ele12_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Ele16_Ele12_Ele8_CaloIdL_TrackIdL
HLT_Mu8_TrkIsoVVL_Ele17_CaloIdL_TrackIdL_IsoVL
HLT_Mu8_TrkIsoVVL_Ele23_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Mu12_TrkIsoVVL_Ele23_CaloIdL_TrackIdL_IsoVL
HLT_Mu12_TrkIsoVVL_Ele23_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Mu17_TrkIsoVVL_Ele12_CaloIdL_TrackIdL_IsoVL
HLT_Mu23_TrkIsoVVL_Ele8_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Mu23_TrkIsoVVL_Ele12_CaloIdL_TrackIdL_IsoVL
HLT_Mu23_TrkIsoVVL_Ele12_CaloIdL_TrackIdL_IsoVL_DZ
HLT_Mu33_Ele33_CaloIdL_GsfTrkIdVL
HLT_Mu37_Ele27_CaloIdL_GsfTrkIdVL
HLT_Mu27_Ele37_CaloIdL_GsfTrkIdVL
HLT_Mu8_DiEle12_CaloIdL_TrackIdL
HLT_Mu12_Photon25_CaloIdL
HLT_Mu12_Photon25_CaloIdL_L1ISO
HLT_Mu12_Photon25_CaloIdL_L1OR
HLT_Mu17_Photon30_CaloIdL_L1ISO
HLT_Mu17_Photon35_CaloIdL_L1ISO
HLT_DiMu9_Ele9_CaloIdL_TrackIdL
HLT_TripleMu_5_3_3_DZ_Mass3p8
HLT_TripleMu_12_10_5
HLT_Mu6_PFHT200_PFMET100
HLT_Ele17_Ele12_CaloIdL_TrackIdL_IsoVL
HLT_Ele23_Ele12_CaloIdL_TrackIdL_IsoVL
HLT_Ele12_CaloIdL_TrackIdL_IsoVL
HLT_Ele17_CaloIdL_GsfTrkIdVL
HLT_Ele17_CaloIdL_TrackIdL_IsoVL
HLT_Ele23_CaloIdL_TrackIdL_IsoVL
HLT_PFHT650_WideJetMJJ900DEtaJJ1p5
HLT_PFHT650_WideJetMJJ950DEtaJJ1p5
HLT_Photon22
HLT_Photon30
HLT_Photon36
HLT_Photon50
HLT_Photon75
HLT_Photon90
HLT_Photon120
HLT_Photon175
HLT_Photon165_HE10
HLT_Photon22_R9Id90_HE10_IsoM
HLT_Photon30_R9Id90_HE10_IsoM
HLT_Photon36_R9Id90_HE10_IsoM
HLT_Photon50_R9Id90_HE10_IsoM
HLT_Photon75_R9Id90_HE10_IsoM
HLT_Photon90_R9Id90_HE10_IsoM
HLT_Photon120_R9Id90_HE10_IsoM
HLT_Photon165_R9Id90_HE10_IsoM
HLT_Diphoton30_18_R9Id_OR_IsoCaloId_AND_HE_R9Id_Mass90
HLT_Diphoton30_18_R9Id_OR_IsoCaloId_AND_HE_R9Id_DoublePixelSeedMatch_Mass70
HLT_Diphoton30PV_18PV_R9Id_AND_IsoCaloId_AND_HE_R9Id_DoublePixelVeto_Mass55
HLT_Diphoton30_18_Solid_R9Id_AND_IsoCaloId_AND_HE_R9Id_Mass55
HLT_Diphoton30EB_18EB_R9Id_OR_IsoCaloId_AND_HE_R9Id_DoublePixelVeto_Mass55
HLT_Dimuon0_Jpsi_Muon
HLT_Dimuon0_Upsilon_Muon
HLT_QuadMuon0_Dimuon0_Jpsi
HLT_QuadMuon0_Dimuon0_Upsilon
HLT_Rsq0p25
HLT_Rsq0p30
HLT_RsqMR270_Rsq0p09_MR200
HLT_RsqMR270_Rsq0p09_MR200_4jet
HLT_Rsq0p02_MR400_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR450_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR500_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_Rsq0p02_MR550_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200
HLT_HT250_DisplacedDijet40_DisplacedTrack
HLT_HT350_DisplacedDijet40_DisplacedTrack
HLT_HT350_DisplacedDijet80_DisplacedTrack
HLT_HT350_DisplacedDijet80_Tight_DisplacedTrack
HLT_HT350_DisplacedDijet40_Inclusive
HLT_HT550_DisplacedDijet80_Inclusive
HLT_HT650_DisplacedDijet80_Inclusive
HLT_HT750_DisplacedDijet80_Inclusive
HLT_VBF_DisplacedJet40_DisplacedTrack
HLT_VBF_DisplacedJet40_DisplacedTrack_2TrackIP2DSig5
HLT_VBF_DisplacedJet40_TightID_DisplacedTrack
HLT_VBF_DisplacedJet40_TightID_Hadronic
HLT_VBF_DisplacedJet40_VTightID_Hadronic
HLT_VBF_DisplacedJet40_VVTightID_Hadronic
HLT_VBF_DisplacedJet40_VTightID_DisplacedTrack
HLT_VBF_DisplacedJet40_VVTightID_DisplacedTrack
HLT_PFMETNoMu110_PFMHTNoMu110_IDTight
HLT_PFMETNoMu120_PFMHTNoMu120_IDTight
HLT_MonoCentralPFJet80_PFMETNoMu110_PFMHTNoMu110_IDTight
HLT_MonoCentralPFJet80_PFMETNoMu120_PFMHTNoMu120_IDTight
HLT_Ele27_eta2p1_WPLoose_Gsf_HT200
HLT_DoubleMu8_Mass8_PFHT300
HLT_Mu8_Ele8_CaloIdM_TrackIdM_Mass8_PFHT300
HLT_DoubleEle8_CaloIdM_TrackIdM_Mass8_PFHT300
HLT_Mu10_CentralPFJet30_BTagCSV_p13
HLT_DoubleMu3_PFMET50
HLT_Ele10_CaloIdM_TrackIdM_CentralPFJet30_BTagCSV_p13
HLT_Ele15_IsoVVVL_BTagCSV_p067_PFHT400
HLT_Ele15_IsoVVVL_PFHT600
HLT_Ele15_IsoVVVL_PFHT400_PFMET50
HLT_Ele15_IsoVVVL_PFHT400
HLT_Ele50_IsoVVVL_PFHT400
HLT_Mu8_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT300_PFMETNoMu60
HLT_Mu10_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT350_PFMETNoMu60
HLT_Mu15_IsoVVVL_BTagCSV_p067_PFHT400
HLT_Mu15_IsoVVVL_PFHT600
HLT_Mu15_IsoVVVL_PFHT400_PFMET50
HLT_Mu15_IsoVVVL_PFHT400
HLT_Mu50_IsoVVVL_PFHT400
HLT_Dimuon16_Jpsi
HLT_Dimuon8_PsiPrime_Barrel
HLT_Dimuon8_Upsilon_Barrel
HLT_Dimuon0_Phi_Barrel
HLT_TrkMu15_DoubleTrkMu5NoFiltersNoVtx
HLT_TrkMu17_DoubleTrkMu8NoFiltersNoVtx
HLT_Mu8
HLT_Mu17
HLT_Mu3_PFJet40
HLT_Ele8_CaloIdM_TrackIdM_PFJet30
HLT_Ele12_CaloIdM_TrackIdM_PFJet30
HLT_Ele17_CaloIdM_TrackIdM_PFJet30
HLT_Ele23_CaloIdM_TrackIdM_PFJet30
HLT_Ele50_CaloIdVT_GsfTrkIdT_PFJet165
HLT_PFHT400_SixJet30_DoubleBTagCSV_p056
HLT_PFHT450_SixJet40_BTagCSV_p056
HLT_PFHT400_SixJet30
HLT_PFHT450_SixJet40
HLT_Ele115_CaloIdVT_GsfTrkIdT
HLT_Ele145_CaloIdVT_GsfTrkIdT
HLT_Ele200_CaloIdVT_GsfTrkIdT
HLT_Mu55
HLT_Photon42_R9Id85_OR_CaloId24b40e_Iso50T80L_Photon25_AND_HE10_R9Id65_Eta2_Mass15
HLT_Photon90_CaloIdL_PFHT600
HLT_FullTracks_Multiplicity80
HLT_FullTracks_Multiplicity100
HLT_FullTracks_Multiplicity130
HLT_FullTracks_Multiplicity150
HLT_ECALHT800
HLT_DiSC30_18_EIso_AND_HE_Mass70
HLT_MET200
HLT_Ele27_HighEta_Ele20_Mass55
HLT_L1FatEvents
HLT_Physics
HLT_L1FatEvents_part0
HLT_L1FatEvents_part1
HLT_L1FatEvents_part2
HLT_L1FatEvents_part3
HLT_Random
HLT_ZeroBias
HLT_ZeroBias_part0
HLT_ZeroBias_part1
HLT_ZeroBias_part2
HLT_ZeroBias_part3
HLT_ZeroBias_part4
HLT_ZeroBias_part5
HLT_ZeroBias_part6
HLT_ZeroBias_part7
HLT_AK4CaloJet30
HLT_AK4CaloJet40
HLT_AK4CaloJet50
HLT_AK4CaloJet80
HLT_AK4CaloJet100
HLT_AK4PFJet30
HLT_AK4PFJet50
HLT_AK4PFJet80
HLT_AK4PFJet100
HLT_HISinglePhoton10
HLT_HISinglePhoton15
HLT_HISinglePhoton20
HLT_HISinglePhoton40
HLT_HISinglePhoton60
HLT_EcalCalibration
HLT_HcalCalibration
HLT_GlobalRunHPDNoise
HLT_L1BptxMinus
HLT_L1BptxPlus
HLT_L1NotBptxOR
HLT_L1MinimumBiasHF_OR_part0
HLT_L1MinimumBiasHF_OR_part1
HLT_L1MinimumBiasHF_OR_part2
HLT_L1MinimumBiasHF_OR_part3
HLT_L1MinimumBiasHF_OR_part4
HLT_L1MinimumBiasHF_OR_part5
HLT_L1MinimumBiasHF_OR_part6
HLT_L1MinimumBiasHF_OR_part7
HLT_L1MinimumBiasHF_OR_part8
HLT_L1MinimumBiasHF_OR_part9
HLT_L1MinimumBiasHF_AND
HLT_HcalNZS
HLT_HcalPhiSym
HLT_HcalIsolatedbunch
HLT_ZeroBias_FirstCollisionAfterAbortGap
HLT_ZeroBias_FirstCollisionAfterAbortGap_copy
HLT_ZeroBias_IsolatedBunches
HLT_ZeroBias_FirstCollisionInTrain
HLT_ZeroBias_FirstBXAfterTrain
HLT_Photon500
HLT_Photon600
HLT_Mu300
HLT_Mu350
HLT_MET250
HLT_MET300
HLT_MET600
HLT_MET700
HLT_PFMET300
HLT_PFMET400
HLT_PFMET500
HLT_PFMET600
HLT_Ele250_CaloIdVT_GsfTrkIdT
HLT_Ele300_CaloIdVT_GsfTrkIdT
HLT_HT2000
HLT_HT2500
HLT_IsoTrackHE
HLT_IsoTrackHB
</code></pre>
<pre><code class="language-python">#import uproot

sample = &quot;ttbar-semileptonic&quot;

root_path = fileset[sample][&quot;files&quot;][0]
print(&quot;Open:&quot;, root_path)

f = uproot.open(root_path)
events = f[&quot;Events&quot;]

print(&quot;# events:&quot;, events.num_entries)

all_keys = events.keys()
print(f&quot;Total braches : {len(all_keys)}&quot;)

</code></pre>
<pre><code>Open: root://eospublic.cern.ch//eos/opendata/cms/mc/RunIISummer20UL16NanoAODv9/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/NANOAODSIM/106X_mcRun2_asymptotic_v17-v1/120000/08FCB2ED-176B-064B-85AB-37B898773B98.root
# events: 1233000
Total braches : 1504
</code></pre>
<pre><code class="language-python">#from dpoa_workshop import pretty_print

pretty_print(all_keys, fmt='35s', require='Muon')
pretty_print(all_keys, fmt='35s', require='Electron')
pretty_print(all_keys, fmt='35s', require='Jet')
pretty_print(all_keys, fmt='35s', require='MET')

</code></pre>
<pre><code>Jet_nMuons                          L1PreFiringWeight_Muon_Nom          
L1PreFiringWeight_Muon_StatDn       L1PreFiringWeight_Muon_StatUp       
L1PreFiringWeight_Muon_SystDn       L1PreFiringWeight_Muon_SystUp       nMuon                               
Muon_dxy                            Muon_dxyErr                         
Muon_dxybs                          Muon_dz                             
Muon_dzErr                          Muon_eta                            
Muon_ip3d                           Muon_jetPtRelv2                     
Muon_jetRelIso                      Muon_mass                           
Muon_miniPFRelIso_all               Muon_miniPFRelIso_chg               
Muon_pfRelIso03_all                 Muon_pfRelIso03_chg                 
Muon_pfRelIso04_all                 Muon_phi                            Muon_pt                             
Muon_ptErr                          Muon_segmentComp                    
Muon_sip3d                          Muon_softMva                        
Muon_tkRelIso                       Muon_tunepRelPt                     
Muon_mvaLowPt                       Muon_mvaTTH                         
Muon_charge                         Muon_jetIdx                         
Muon_nStations                      Muon_nTrackerLayers                 
Muon_pdgId                          Muon_tightCharge                    
Muon_fsrPhotonIdx                   Muon_highPtId                       
Muon_highPurity                     Muon_inTimeMuon                     
Muon_isGlobal                       Muon_isPFcand                       
Muon_isStandalone                   Muon_isTracker                      
Muon_jetNDauCharged                 Muon_looseId                        
Muon_mediumId                       Muon_mediumPromptId                 
Muon_miniIsoId                      Muon_multiIsoId                     
Muon_mvaId                          Muon_mvaLowPtId                     
Muon_pfIsoId                        Muon_puppiIsoId                     
Muon_softId                         Muon_softMvaId                      
Muon_tightId                        Muon_tkIsoId                        
Muon_triggerIdLoose                 Muon_genPartIdx                     
Muon_genPartFlav                    Muon_cleanmask                      
Flag_BadPFMuonFilter                Flag_BadPFMuonDzFilter              
Flag_BadPFMuonSummer16Filter        HLT_Dimuon0_Jpsi_Muon               
HLT_Dimuon0_Upsilon_Muon            HLT_QuadMuon0_Dimuon0_Jpsi          
HLT_QuadMuon0_Dimuon0_Upsilon       
nElectron                           Electron_dEscaleDown                
Electron_dEscaleUp                  Electron_dEsigmaDown                
Electron_dEsigmaUp                  Electron_deltaEtaSC                 
Electron_dr03EcalRecHitSumEt        Electron_dr03HcalDepth1TowerSumEt   
Electron_dr03TkSumPt                Electron_dr03TkSumPtHEEP            
Electron_dxy                        Electron_dxyErr                     
Electron_dz                         Electron_dzErr                      
Electron_eCorr                      Electron_eInvMinusPInv              
Electron_energyErr                  Electron_eta                        
Electron_hoe                        Electron_ip3d                       
Electron_jetPtRelv2                 Electron_jetRelIso                  
Electron_mass                       Electron_miniPFRelIso_all           
Electron_miniPFRelIso_chg           Electron_mvaFall17V2Iso             
Electron_mvaFall17V2noIso           Electron_pfRelIso03_all             
Electron_pfRelIso03_chg             Electron_phi                        
Electron_pt                         Electron_r9                         
Electron_scEtOverPt                 Electron_sieie                      
Electron_sip3d                      Electron_mvaTTH                     
Electron_charge                     Electron_cutBased                   
Electron_jetIdx                     Electron_pdgId                      
Electron_photonIdx                  Electron_tightCharge                
Electron_vidNestedWPBitmap          Electron_vidNestedWPBitmapHEEP      
Electron_convVeto                   Electron_cutBased_HEEP              
Electron_isPFcand                   Electron_jetNDauCharged             
Electron_lostHits                   Electron_mvaFall17V2Iso_WP80        
Electron_mvaFall17V2Iso_WP90        Electron_mvaFall17V2Iso_WPL         
Electron_mvaFall17V2noIso_WP80      Electron_mvaFall17V2noIso_WP90      
Electron_mvaFall17V2noIso_WPL       Electron_seedGain                   
Jet_nElectrons                      nLowPtElectron                      
LowPtElectron_ID                    LowPtElectron_convVtxRadius         
LowPtElectron_deltaEtaSC            LowPtElectron_dxy                   
LowPtElectron_dxyErr                LowPtElectron_dz                    
LowPtElectron_dzErr                 LowPtElectron_eInvMinusPInv         
LowPtElectron_embeddedID            LowPtElectron_energyErr             
LowPtElectron_eta                   LowPtElectron_hoe                   
LowPtElectron_mass                  LowPtElectron_miniPFRelIso_all      
LowPtElectron_miniPFRelIso_chg      LowPtElectron_phi                   
LowPtElectron_pt                    LowPtElectron_ptbiased              
LowPtElectron_r9                    LowPtElectron_scEtOverPt            
LowPtElectron_sieie                 LowPtElectron_unbiased              
LowPtElectron_charge                LowPtElectron_convWP                
LowPtElectron_pdgId                 LowPtElectron_convVeto              
LowPtElectron_lostHits              Electron_genPartIdx                 
Electron_genPartFlav                LowPtElectron_genPartIdx            
LowPtElectron_genPartFlav           Electron_cleanmask                  
nCorrT1METJet                       CorrT1METJet_area                   
CorrT1METJet_eta                    CorrT1METJet_muonSubtrFactor        
CorrT1METJet_phi                    CorrT1METJet_rawPt                  nFatJet                             
FatJet_area                         FatJet_btagCSVV2                    
FatJet_btagDDBvLV2                  FatJet_btagDDCvBV2                  
FatJet_btagDDCvLV2                  FatJet_btagDeepB                    
FatJet_btagHbb                      FatJet_deepTagMD_H4qvsQCD           
FatJet_deepTagMD_HbbvsQCD           FatJet_deepTagMD_TvsQCD             
FatJet_deepTagMD_WvsQCD             FatJet_deepTagMD_ZHbbvsQCD          
FatJet_deepTagMD_ZHccvsQCD          FatJet_deepTagMD_ZbbvsQCD           
FatJet_deepTagMD_ZvsQCD             FatJet_deepTagMD_bbvsLight          
FatJet_deepTagMD_ccvsLight          FatJet_deepTag_H                    
FatJet_deepTag_QCD                  FatJet_deepTag_QCDothers            
FatJet_deepTag_TvsQCD               FatJet_deepTag_WvsQCD               
FatJet_deepTag_ZvsQCD               FatJet_eta                          
FatJet_mass                         FatJet_msoftdrop                    
FatJet_n2b1                         FatJet_n3b1                         
FatJet_particleNetMD_QCD            FatJet_particleNetMD_Xbb            
FatJet_particleNetMD_Xcc            FatJet_particleNetMD_Xqq            
FatJet_particleNet_H4qvsQCD         FatJet_particleNet_HbbvsQCD         
FatJet_particleNet_HccvsQCD         FatJet_particleNet_QCD              
FatJet_particleNet_TvsQCD           FatJet_particleNet_WvsQCD           
FatJet_particleNet_ZvsQCD           FatJet_particleNet_mass             
FatJet_phi                          FatJet_pt                           
FatJet_rawFactor                    FatJet_tau1                         
FatJet_tau2                         FatJet_tau3                         
FatJet_tau4                         FatJet_lsf3                         
FatJet_jetId                        FatJet_subJetIdx1                   
FatJet_subJetIdx2                   FatJet_electronIdx3SJ               
FatJet_muonIdx3SJ                   FatJet_nConstituents                
nGenJetAK8                          GenJetAK8_eta                       
GenJetAK8_mass                      GenJetAK8_phi                       
GenJetAK8_pt                        nGenJet                             
GenJet_eta                          GenJet_mass                         
GenJet_phi                          GenJet_pt                           
nSubGenJetAK8                       SubGenJetAK8_eta                    
SubGenJetAK8_mass                   SubGenJetAK8_phi                    
SubGenJetAK8_pt                     nJet                                Jet_area                            
Jet_btagCSVV2                       Jet_btagDeepB                       
Jet_btagDeepCvB                     Jet_btagDeepCvL                     
Jet_btagDeepFlavB                   Jet_btagDeepFlavCvB                 
Jet_btagDeepFlavCvL                 Jet_btagDeepFlavQG                  
Jet_chEmEF                          Jet_chFPV0EF                        
Jet_chHEF                           Jet_eta                             
Jet_hfsigmaEtaEta                   Jet_hfsigmaPhiPhi                   Jet_mass                            
Jet_muEF                            Jet_muonSubtrFactor                 
Jet_neEmEF                          Jet_neHEF                           Jet_phi                             
Jet_pt                              Jet_puIdDisc                        Jet_qgl                             
Jet_rawFactor                       Jet_bRegCorr                        
Jet_bRegRes                         Jet_cRegCorr                        
Jet_cRegRes                         Jet_electronIdx1                    
Jet_electronIdx2                    Jet_hfadjacentEtaStripsSize         
Jet_hfcentralEtaStripSize           Jet_jetId                           
Jet_muonIdx1                        Jet_muonIdx2                        
Jet_nElectrons                      Jet_nMuons                          Jet_puId                            
Jet_nConstituents                   nSoftActivityJet                    
SoftActivityJet_eta                 SoftActivityJet_phi                 
SoftActivityJet_pt                  SoftActivityJetHT                   
SoftActivityJetHT10                 SoftActivityJetHT2                  
SoftActivityJetHT5                  SoftActivityJetNjets10              
SoftActivityJetNjets2               SoftActivityJetNjets5               nSubJet                             
SubJet_btagCSVV2                    SubJet_btagDeepB                    
SubJet_eta                          SubJet_mass                         
SubJet_n2b1                         SubJet_n3b1                         
SubJet_phi                          SubJet_pt                           
SubJet_rawFactor                    SubJet_tau1                         
SubJet_tau2                         SubJet_tau3                         
SubJet_tau4                         FatJet_genJetAK8Idx                 
FatJet_hadronFlavour                FatJet_nBHadrons                    
FatJet_nCHadrons                    GenJetAK8_partonFlavour             
GenJetAK8_hadronFlavour             GenJet_partonFlavour                
GenJet_hadronFlavour                Jet_genJetIdx                       
Jet_hadronFlavour                   Jet_partonFlavour                   
Jet_cleanmask                       SubJet_hadronFlavour                
SubJet_nBHadrons                    SubJet_nCHadrons                    
L1_DoubleJet12_ForwardBackward      L1_DoubleJet16_ForwardBackward      
L1_DoubleJet8_ForwardBackward       L1_DoubleJetC100                    
L1_DoubleJetC112                    L1_DoubleJetC120                    
L1_DoubleJetC40                     L1_DoubleJetC50                     
L1_DoubleJetC60                     L1_DoubleJetC60_ETM60               
L1_DoubleJetC80                     L1_ETM75_Jet60_dPhi_Min0p4          
L1_Jet32_DoubleMu_10_0_dPhi_Jet_Mu0_Max0p4_dPhi_Mu_Mu_Min1p0 
L1_Jet32_Mu0_EG10_dPhi_Jet_Mu_Max0p4_dPhi_Mu_EG_Min1p0 L1_Mu3_JetC120                      
L1_Mu3_JetC120_dEta_Max0p4_dPhi_Max0p4 L1_Mu3_JetC16                       
L1_Mu3_JetC16_dEta_Max0p4_dPhi_Max0p4 L1_Mu3_JetC60                       
L1_Mu3_JetC60_dEta_Max0p4_dPhi_Max0p4 L1_QuadJetC36_Tau52                 
L1_QuadJetC40                       L1_QuadJetC50                       
L1_QuadJetC60                       L1_SingleJet120                     
L1_SingleJet12_BptxAND              L1_SingleJet140                     
L1_SingleJet150                     L1_SingleJet16                      
L1_SingleJet160                     L1_SingleJet170                     
L1_SingleJet180                     L1_SingleJet20                      
L1_SingleJet200                     L1_SingleJet35                      
L1_SingleJet60                      L1_SingleJet8_BptxAND               
L1_SingleJet90                      L1_SingleJetC20_NotBptxOR           
L1_SingleJetC20_NotBptxOR_3BX       L1_SingleJetC32_NotBptxOR           
L1_SingleJetC32_NotBptxOR_3BX       L1_SingleJetC36_NotBptxOR_3BX       
L1_TripleJet_84_68_48_VBF           L1_TripleJet_88_72_56_VBF           
L1_TripleJet_92_76_64_VBF           HLT_AK8PFJet360_TrimMass30          
HLT_AK8PFJet400_TrimMass30          HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p20 
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p087 
HLT_AK8DiPFJet300_200_TrimMass30_BTagCSV_p087 HLT_AK8DiPFJet300_200_TrimMass30    
HLT_AK8DiPFJet280_200_TrimMass30    HLT_AK8DiPFJet250_200_TrimMass30    
HLT_AK8DiPFJet280_200_TrimMass30_BTagCSV_p20 
HLT_AK8DiPFJet250_200_TrimMass30_BTagCSV_p20 HLT_CaloJet260                      
HLT_CaloJet500_NoJetID              HLT_Ele27_WPTight_Gsf_L1JetTauSeeded 
HLT_Ele35_CaloIdVT_GsfTrkIdT_PFJet150_PFJet50 
HLT_Ele45_WPLoose_Gsf_L1JetTauSeeded 
HLT_Ele45_CaloIdVT_GsfTrkIdT_PFJet200_PFJet50 HLT_JetE30_NoBPTX3BX                
HLT_JetE30_NoBPTX                   HLT_JetE50_NoBPTX3BX                
HLT_JetE70_NoBPTX3BX                HLT_Mu30_eta2p1_PFJet150_PFJet50    
HLT_Mu40_eta2p1_PFJet200_PFJet50    
HLT_Mu33NoFiltersNoVtxDisplaced_DisplacedJet50_Tight 
HLT_Mu33NoFiltersNoVtxDisplaced_DisplacedJet50_Loose 
HLT_Mu28NoFiltersNoVtx_DisplacedJet40_Loose 
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Tight 
HLT_Mu38NoFiltersNoVtxDisplaced_DisplacedJet60_Loose 
HLT_Mu38NoFiltersNoVtx_DisplacedJet60_Loose 
HLT_Mu28NoFiltersNoVtx_CentralCaloJet40 HLT_PFHT550_4JetPt50                
HLT_PFHT650_4JetPt50                HLT_PFHT750_4JetPt50                
HLT_PFHT750_4JetPt70                HLT_PFHT750_4JetPt80                
HLT_PFHT800_4JetPt50                HLT_PFHT850_4JetPt50                
HLT_PFJet15_NoCaloMatched           HLT_PFJet25_NoCaloMatched           
HLT_DiPFJet15_NoCaloMatched         HLT_DiPFJet25_NoCaloMatched         
HLT_DiPFJet15_FBEta3_NoCaloMatched  HLT_DiPFJet25_FBEta3_NoCaloMatched  
HLT_DiPFJetAve15_HFJEC              HLT_DiPFJetAve25_HFJEC              
HLT_DiPFJetAve35_HFJEC              HLT_AK8PFJet40                      
HLT_AK8PFJet60                      HLT_AK8PFJet80                      
HLT_AK8PFJet140                     HLT_AK8PFJet200                     
HLT_AK8PFJet260                     HLT_AK8PFJet320                     
HLT_AK8PFJet400                     HLT_AK8PFJet450                     
HLT_AK8PFJet500                     HLT_PFJet40                         
HLT_PFJet60                         HLT_PFJet80                         
HLT_PFJet140                        HLT_PFJet200                        
HLT_PFJet260                        HLT_PFJet320                        
HLT_PFJet400                        HLT_PFJet450                        
HLT_PFJet500                        HLT_DiPFJetAve40                    
HLT_DiPFJetAve60                    HLT_DiPFJetAve80                    
HLT_DiPFJetAve140                   HLT_DiPFJetAve200                   
HLT_DiPFJetAve260                   HLT_DiPFJetAve320                   
HLT_DiPFJetAve400                   HLT_DiPFJetAve500                   
HLT_DiPFJetAve60_HFJEC              HLT_DiPFJetAve80_HFJEC              
HLT_DiPFJetAve100_HFJEC             HLT_DiPFJetAve160_HFJEC             
HLT_DiPFJetAve220_HFJEC             HLT_DiPFJetAve300_HFJEC             
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu140 
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu80 HLT_DiCentralPFJet170               
HLT_SingleCentralPFJet170_CFMax0p1  HLT_DiCentralPFJet170_CFMax0p1      
HLT_DiCentralPFJet220_CFMax0p3      HLT_DiCentralPFJet330_CFMax0p5      
HLT_DiCentralPFJet430               HLT_PFHT200_DiPFJetAve90_PFAlphaT0p57 
HLT_PFHT200_DiPFJetAve90_PFAlphaT0p63 HLT_PFHT250_DiPFJetAve90_PFAlphaT0p55 
HLT_PFHT250_DiPFJetAve90_PFAlphaT0p58 HLT_PFHT300_DiPFJetAve90_PFAlphaT0p53 
HLT_PFHT300_DiPFJetAve90_PFAlphaT0p54 HLT_PFHT350_DiPFJetAve90_PFAlphaT0p52 
HLT_PFHT350_DiPFJetAve90_PFAlphaT0p53 HLT_PFHT400_DiPFJetAve90_PFAlphaT0p51 
HLT_PFHT400_DiPFJetAve90_PFAlphaT0p52 HLT_PFMET170_JetIdCleaned           
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq200 HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq460 
HLT_QuadPFJet_BTagCSV_p016_p11_VBF_Mqq240 HLT_QuadPFJet_BTagCSV_p016_VBF_Mqq500 
HLT_QuadPFJet_VBF                   HLT_L1_TripleJet_VBF                
HLT_QuadJet45_TripleBTagCSV_p087    HLT_QuadJet45_DoubleBTagCSV_p087    
HLT_DoubleJet90_Double30_TripleBTagCSV_p087 
HLT_DoubleJet90_Double30_DoubleBTagCSV_p087 
HLT_DoubleJetsC100_DoubleBTagCSV_p026_DoublePFJetsC160 
HLT_DoubleJetsC100_DoubleBTagCSV_p014_DoublePFJetsC100MaxDeta1p6 
HLT_DoubleJetsC112_DoubleBTagCSV_p026_DoublePFJetsC172 
HLT_DoubleJetsC112_DoubleBTagCSV_p014_DoublePFJetsC112MaxDeta1p6 
HLT_DoubleJetsC100_SingleBTagCSV_p026 HLT_DoubleJetsC100_SingleBTagCSV_p014 
HLT_DoubleJetsC100_SingleBTagCSV_p026_SinglePFJetC350 
HLT_DoubleJetsC100_SingleBTagCSV_p014_SinglePFJetC350 
HLT_Ele8_CaloIdL_TrackIdL_IsoVL_PFJet30 HLT_Ele12_CaloIdL_TrackIdL_IsoVL_PFJet30 
HLT_Ele17_CaloIdL_TrackIdL_IsoVL_PFJet30 
HLT_Ele23_CaloIdL_TrackIdL_IsoVL_PFJet30 HLT_BTagMu_DiJet20_Mu5              
HLT_BTagMu_DiJet40_Mu5              HLT_BTagMu_DiJet70_Mu5              
HLT_BTagMu_DiJet110_Mu5             HLT_BTagMu_DiJet170_Mu5             
HLT_BTagMu_Jet300_Mu5               HLT_BTagMu_AK8Jet300_Mu5            
HLT_Ele23_Ele12_CaloIdL_TrackIdL_IsoVL_DZ_L1JetTauSeeded 
HLT_PFHT650_WideJetMJJ900DEtaJJ1p5  HLT_PFHT650_WideJetMJJ950DEtaJJ1p5  
HLT_Rsq0p02_MR300_TriPFJet80_60_40_BTagCSV_p063_p20_Mbb60_200 
HLT_Rsq0p02_MR400_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200 
HLT_Rsq0p02_MR450_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200 
HLT_Rsq0p02_MR500_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200 
HLT_Rsq0p02_MR550_TriPFJet80_60_40_DoubleBTagCSV_p063_Mbb60_200 
HLT_VBF_DisplacedJet40_DisplacedTrack 
HLT_VBF_DisplacedJet40_DisplacedTrack_2TrackIP2DSig5 
HLT_VBF_DisplacedJet40_TightID_DisplacedTrack HLT_VBF_DisplacedJet40_Hadronic     
HLT_VBF_DisplacedJet40_Hadronic_2PromptTrack 
HLT_VBF_DisplacedJet40_TightID_Hadronic HLT_VBF_DisplacedJet40_VTightID_Hadronic 
HLT_VBF_DisplacedJet40_VVTightID_Hadronic 
HLT_VBF_DisplacedJet40_VTightID_DisplacedTrack 
HLT_VBF_DisplacedJet40_VVTightID_DisplacedTrack 
HLT_MonoCentralPFJet80_PFMETNoMu90_PFMHTNoMu90_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu100_PFMHTNoMu100_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu110_PFMHTNoMu110_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu120_PFMHTNoMu120_IDTight 
HLT_Mu10_CentralPFJet30_BTagCSV_p13 
HLT_Ele10_CaloIdM_TrackIdM_CentralPFJet30_BTagCSV_p13 
HLT_Mu8_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT300_PFMETNoMu60 
HLT_Mu10_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT350_PFMETNoMu60 HLT_Mu3_PFJet40                     
HLT_Ele8_CaloIdM_TrackIdM_PFJet30   HLT_Ele12_CaloIdM_TrackIdM_PFJet30  
HLT_Ele17_CaloIdM_TrackIdM_PFJet30  HLT_Ele23_CaloIdM_TrackIdM_PFJet30  
HLT_Ele50_CaloIdVT_GsfTrkIdT_PFJet140 HLT_Ele50_CaloIdVT_GsfTrkIdT_PFJet165 
HLT_PFHT400_SixJet30_DoubleBTagCSV_p056 HLT_PFHT450_SixJet40_BTagCSV_p056   
HLT_PFHT400_SixJet30                HLT_PFHT450_SixJet40                
HLT_AK4CaloJet30                    HLT_AK4CaloJet40                    
HLT_AK4CaloJet50                    HLT_AK4CaloJet80                    
HLT_AK4CaloJet100                   HLT_AK4PFJet30                      
HLT_AK4PFJet50                      HLT_AK4PFJet80                      
HLT_AK4PFJet100                     
CaloMET_phi                         CaloMET_pt                          
CaloMET_sumEt                       ChsMET_phi                          
ChsMET_pt                           ChsMET_sumEt                        
nCorrT1METJet                       CorrT1METJet_area                   
CorrT1METJet_eta                    CorrT1METJet_muonSubtrFactor        
CorrT1METJet_phi                    CorrT1METJet_rawPt                  
DeepMETResolutionTune_phi           DeepMETResolutionTune_pt            
DeepMETResponseTune_phi             DeepMETResponseTune_pt              
GenMET_phi                          GenMET_pt                           
MET_MetUnclustEnUpDeltaX            MET_MetUnclustEnUpDeltaY            
MET_covXX                           MET_covXY                           
MET_covYY                           MET_phi                             MET_pt                              
MET_significance                    MET_sumEt                           
MET_sumPtUnclustered                PuppiMET_phi                        
PuppiMET_phiJERDown                 PuppiMET_phiJERUp                   
PuppiMET_phiJESDown                 PuppiMET_phiJESUp                   
PuppiMET_phiUnclusteredDown         PuppiMET_phiUnclusteredUp           
PuppiMET_pt                         PuppiMET_ptJERDown                  
PuppiMET_ptJERUp                    PuppiMET_ptJESDown                  
PuppiMET_ptJESUp                    PuppiMET_ptUnclusteredDown          
PuppiMET_ptUnclusteredUp            PuppiMET_sumEt                      
RawMET_phi                          RawMET_pt                           
RawMET_sumEt                        RawPuppiMET_phi                     
RawPuppiMET_pt                      RawPuppiMET_sumEt                   
TkMET_phi                           TkMET_pt                            
TkMET_sumEt                         MET_fiducialGenPhi                  
MET_fiducialGenPt                   Flag_METFilters                     
HLT_HT250_CaloMET70                 HLT_Mu16_eta2p1_MET30               
HLT_IsoMu16_eta2p1_MET30            
HLT_IsoMu16_eta2p1_MET30_LooseIsoPFTau50_Trk30_eta2p1 
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET80 HLT_LooseIsoPFTau50_Trk30_eta2p1_MET90 
HLT_LooseIsoPFTau50_Trk30_eta2p1_MET110 HLT_LooseIsoPFTau50_Trk30_eta2p1_MET120 
HLT_PFHT300_PFMET100                HLT_PFHT300_PFMET110                
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu140 
HLT_DiPFJet40_DEta3p5_MJJ600_PFMETNoMu80 HLT_MET60_IsoTrk35_Loose            
HLT_MET75_IsoTrk50                  HLT_MET90_IsoTrk50                  
HLT_PFMET120_BTagCSV_p067           HLT_PFMET120_Mu5                    
HLT_PFMET170_NotCleaned             HLT_PFMET170_NoiseCleaned           
HLT_PFMET170_HBHECleaned            HLT_PFMET170_JetIdCleaned           
HLT_PFMET170_BeamHaloCleaned        HLT_PFMET170_HBHE_BeamHaloCleaned   
HLT_PFMETTypeOne190_HBHE_BeamHaloCleaned HLT_PFMET90_PFMHT90_IDTight         
HLT_PFMET100_PFMHT100_IDTight       
HLT_PFMET100_PFMHT100_IDTight_BeamHaloCleaned HLT_PFMET110_PFMHT110_IDTight       
HLT_PFMET120_PFMHT120_IDTight       
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight_BTagCSV_p067 
HLT_CaloMHTNoPU90_PFMET90_PFMHT90_IDTight HLT_Photon135_PFMET100              
HLT_Photon22_R9Id90_HE10_Iso40_EBOnly_PFMET40 
HLT_Photon36_R9Id90_HE10_Iso40_EBOnly_PFMET40 
HLT_Photon50_R9Id90_HE10_Iso40_EBOnly_PFMET40 
HLT_Photon75_R9Id90_HE10_Iso40_EBOnly_PFMET40 
HLT_Photon90_R9Id90_HE10_Iso40_EBOnly_PFMET40 
HLT_Photon120_R9Id90_HE10_Iso40_EBOnly_PFMET40 HLT_Mu3er_PFHT140_PFMET125          
HLT_Mu6_PFHT200_PFMET80_BTagCSV_p067 HLT_Mu6_PFHT200_PFMET100            
HLT_Mu14er_PFMET100                 HLT_PFMETNoMu90_PFMHTNoMu90_IDTight 
HLT_PFMETNoMu100_PFMHTNoMu100_IDTight HLT_PFMETNoMu110_PFMHTNoMu110_IDTight 
HLT_PFMETNoMu120_PFMHTNoMu120_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu90_PFMHTNoMu90_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu100_PFMHTNoMu100_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu110_PFMHTNoMu110_IDTight 
HLT_MonoCentralPFJet80_PFMETNoMu120_PFMHTNoMu120_IDTight HLT_DoubleMu3_PFMET50               
HLT_Ele15_IsoVVVL_PFHT350_PFMET50   HLT_Ele15_IsoVVVL_PFHT400_PFMET50   
HLT_Mu8_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT300_PFMETNoMu60 
HLT_Mu10_TrkIsoVVL_DiPFJet40_DEta3p5_MJJ750_HTT350_PFMETNoMu60 
HLT_Mu15_IsoVVVL_PFHT350_PFMET50    HLT_Mu15_IsoVVVL_PFHT400_PFMET50    
HLT_MET100                          HLT_MET150                          
HLT_MET200                          HLT_MET250                          
HLT_MET300                          HLT_MET600                          
HLT_MET700                          HLT_PFMET300                        
HLT_PFMET400                        HLT_PFMET500                        
HLT_PFMET600
</code></pre>
<pre><code class="language-python">if &quot;genWeight&quot; in events.keys():
    gw = events[&quot;genWeight&quot;].array(entry_stop=100_000, library=&quot;np&quot;)
    print(f&quot;genWeight: mean={gw.mean():.3f}, std={gw.std():.3f}, negativos={(gw&lt;0).mean():.2%}&quot;)
else:
    print(&quot;There is no genWeight&quot;)

</code></pre>
<pre><code>genWeight: mean=300.828, std=39.097, negativos=0.42%
</code></pre>
<p>Because std &gt; 0 and negativos &gt; 0, you have learned a golden rule for this dataset:</p>
<p>NEVER count events.</p>
<p>Wrong: N = len(events)</p>
<p>Right: N = sum(events.genWeight)</p>
<p>If you just count them (len), you will be wrong by 0.84% (counting the negatives as positives instead of subtracting them).</p>
<p><strong>“Now the goal is to explore the characteristic variables of these events and visualize them. We are not applying any cuts yet; this step is simply to inspect the raw distributions. For this, we will use the following:”</strong></p>
<p><strong>Note:</strong></p>
<p>Notice that we could reuse the dictionary built earlier (<code>fileset</code>) to automatically loop over all available datasets. However, for debugging and flexibility, a manual list of datasets was defined. At the beginning, only a few datasets were used for quick tests, and later this list was expanded to match the same datasets contained in the <code>fileset</code>. This approach allows easier control during development while keeping compatibility with the full processing workflow.</p>
<pre><code class="language-python">#import uproot
#import awkward as ak
#import numpy as np
#import matplotlib.pyplot as plt


selected_datasets = [
    'SingleMuon', 'SingleElectron', 
    'ttbar-semileptonic', 't-channel-top', 'ttW', 
    'WJets-HT400to600', 'DYJets-Zpt200', 
    'WW', 'ZZ', 'Zvv'
]

variables = [
    &quot;Muon_pt&quot;, &quot;Muon_eta&quot;,
    &quot;Jet_pt&quot;, &quot;Jet_btagDeepFlavB&quot;, 
    &quot;MET_pt&quot;,
    &quot;nJet&quot;, &quot;nMuon&quot;, &quot;nElectron&quot;
]


max_files = 1


data = {} 


for ds_name in selected_datasets:

    #################################3

    if ds_name not in fileset:
        print(f&quot;Skipping {ds_name}: Not found in fileset&quot;)
        continue
     ####################################   


    file_list = fileset[ds_name][&quot;files&quot;][:max_files]

    print(f&quot;Reading {ds_name}: {len(file_list)} files...&quot;)

    # We need a temporary place to hold data chunks from multiple files
    # Structure: temp_storage[&quot;Muon_pt&quot;] = [ [array_file1], [array_file2] ]
    temp_storage = {var: [] for var in variables}

    # Loop over the selected files
    for file_path in file_list:
        try:
            with uproot.open(f&quot;{file_path}:Events&quot;) as f:

                # Read raw data
                raw_data = f.arrays(variables, library=&quot;ak&quot;)

                for var in variables:
                    # Flatten the data for this specific file
                    flat_array = ak.to_numpy(ak.flatten(raw_data[var], axis=None))

                    # Add to our temporary list
                    temp_storage[var].append(flat_array)

        except Exception as e:
            print(f&quot;  Error reading file in {ds_name}: {e}&quot;)


    data[ds_name] = {}

    for var in variables:
        if len(temp_storage[var]) &gt; 0:
            # np.concatenate joins the list of arrays into one big array
            data[ds_name][var] = np.concatenate(temp_storage[var])
        else:
            data[ds_name][var] = np.array([]) # Empty if something went wrong


</code></pre>
<pre><code>Reading SingleMuon: 1 files...
Reading SingleElectron: 1 files...
Reading ttbar-semileptonic: 1 files...
Reading t-channel-top: 1 files...
Reading ttW: 1 files...
Reading WJets-HT400to600: 1 files...
Reading DYJets-Zpt200: 1 files...
Reading WW: 1 files...
Reading ZZ: 1 files...
Reading Zvv: 1 files...
</code></pre>
<pre><code class="language-python">plt.rcParams.update({'font.size': 12})

for var in variables:

    plt.figure(figsize=(8, 6))

    # Loop through the data we just loaded
    for ds_name in selected_datasets:

        # Check if we have data for this combination
        if ds_name in data and var in data[ds_name]:

            values = data[ds_name][var]

            # Check if empty
            if len(values) == 0: continue



       ########################################################     


            plt.hist(
                values, 
                bins=50, 
                # Automatic range: cut off the top 1% outliers so plot looks good
                range=(0, np.percentile(values, 99)), 
                histtype='bar',   
                linewidth=2,      
                label=ds_name      # Name in legend
            )

    plt.xlabel(var)
    plt.ylabel(&quot;Events&quot;)
    plt.legend()
    plt.tight_layout()
    plt.show()
</code></pre>
<p><img alt="png" src="../output_34_0.png" /></p>
<p><img alt="png" src="../output_34_1.png" /></p>
<p><img alt="png" src="../output_34_2.png" /></p>
<p><img alt="png" src="../output_34_3.png" /></p>
<p><img alt="png" src="../output_34_4.png" /></p>
<p><img alt="png" src="../output_34_5.png" /></p>
<p><img alt="png" src="../output_34_6.png" /></p>
<p><img alt="png" src="../output_34_7.png" /></p>
<p><strong>“Because data and MC have very different event counts, we cannot compare their raw histograms directly. For now, we normalize each distribution so that its integral equals 1. This lets us compare the <em>shape</em> of the variables without worrying about absolute yields:”</strong></p>
<pre><code class="language-python"># --- NORMALIZATION ---
# We create weights so the sum of the histogram equals 1.
# This allows us to compare SHAPES, not counts.
weights = np.ones_like(vals) / len(vals)
</code></pre>
<p>Then copy the previous block and add this line, and in plt.his add weights</p>
<pre><code class="language-python">

plt.rcParams.update({'font.size': 12})

for var in variables:

    plt.figure(figsize=(8, 6))

    for ds_name in selected_datasets:

        # Check for data
        if ds_name in data and var in data[ds_name]:

            vals = data[ds_name][var]
            if len(vals) == 0: continue

            # --- NORMALIZATION STEP ---
            # Create an array of weights where every entry is (1 / total_events)
            # When summed up by the histogram, the total area will be 1.0
            weights = np.ones_like(vals) / len(vals)

            # --- PLOT ---
            plt.hist(
                vals, 
                bins=50, 
                range=(0, np.percentile(vals, 99)), 
                weights=weights,   # APPLY WEIGHTS HERE
                histtype='bar',   
                linewidth=2,       
                label=ds_name      
            )

    # Labels
    plt.xlabel(var)
    plt.ylabel(&quot;Fraction of Events (Normalized)&quot;) # Changed label
    plt.legend()
    plt.tight_layout()
    plt.show()
</code></pre>
<p><img alt="png" src="../output_36_0.png" /></p>
<p><img alt="png" src="../output_36_1.png" /></p>
<p><img alt="png" src="../output_36_2.png" /></p>
<p><img alt="png" src="../output_36_3.png" /></p>
<p><img alt="png" src="../output_36_4.png" /></p>
<p><img alt="png" src="../output_36_5.png" /></p>
<p><img alt="png" src="../output_36_6.png" /></p>
<p><img alt="png" src="../output_36_7.png" /></p>
<p><strong>The workflow proceeds in three main steps:</strong></p>
<ol>
<li>
<p><strong>Apply the baseline selection</strong>
   We first select events that match the single-lepton topology (electron or muon).
   This removes events that clearly do not belong to the channel and defines the core event structure we will work with.</p>
</li>
<li>
<p><strong>Filter the events</strong>
   After the baseline, we keep only the events that satisfy these basic criteria.
   This produces a clean and well-defined sample for further analysis.</p>
</li>
<li>
<p><strong>Apply additional cuts to build CR and SR</strong>
   With the filtered sample, we introduce extra requirements to define:</p>
</li>
<li>
<p><strong>Control Regions (CR):</strong> used to study and validate the dominant backgrounds.</p>
</li>
<li><strong>Signal Region (SR):</strong> where the dark-matter search is performed.</li>
</ol>
<p>This step-by-step structure mirrors the logic used in the CMS paper and ensures a transparent and reproducible analysis flow.</p>
<p><strong>So all of this is reflected in the tables, which are directly the cuts we should use, 
and we don't have to explore it ourselves in this case for this guide.</strong></p>
<h3 id="base-line">Base line</h3>
<p>If you read the drafts</p>
<h4 id="table-10-baseline-selection-sl-and-ah"><strong>Table 10 — Baseline Selection (SL and AH)</strong></h4>
<h4 id="what-does-it-contain"><strong>What does it contain?</strong></h4>
<p>The <strong>minimum or baseline selection</strong> that every event must satisfy <strong>before being assigned to any region</strong> (Signal or Control).</p>
<p>It includes:</p>
<ul>
<li>Lepton quality and type (muons, electrons)</li>
<li>Minimum cuts on <strong>pT</strong> and <strong>η</strong></li>
<li>Requirements on <strong>jets</strong> and <strong>b-jets</strong></li>
<li>Event-cleaning criteria</li>
<li><strong>Additional-lepton veto</strong></li>
</ul>
<h3 id="what-is-it-for"><strong>What is it for?</strong></h3>
<p>It acts as the <strong>universal first filter</strong> of the analysis.
No event enters the SR or CR without passing this baseline.</p>
<hr />
<h4 id="tables-11-and-12-expected-events-after-optimized-cuts-sl-and-ah"><strong>Tables 11 and 12 — Expected Events After Optimized Cuts (SL and AH)</strong></h4>
<h4 id="what-do-they-contain"><strong>What do they contain?</strong></h4>
<p>Tables showing:</p>
<ul>
<li>Expected event yields for each <strong>background</strong></li>
<li>Predictions for different <strong>signal models</strong></li>
<li>Results after the baseline plus <strong>optimized cuts</strong></li>
</ul>
<h4 id="what-is-it-for_1"><strong>What is it for?</strong></h4>
<p>These tables serve <strong>only for internal validation</strong> in the paper:</p>
<ul>
<li>Checking consistency between simulated backgrounds and signals</li>
<li>Showing how many events remain under different signal hypotheses</li>
</ul>
<pre><code class="language-python">from IPython.display import Image, display

display(Image(filename=&quot;Table_10.png&quot;))

</code></pre>
<p><img alt="png" src="../output_41_0.png" /></p>
<h3 id="single-muon">Single Muon</h3>
<p>1.“Load all physics objects (muons, electrons, jets, MET) from the ROOT file and package them as 4-vectors. This prepares the event for the physics selections that follow.”</p>
<p>2.“Apply the baseline selection: require exactly one tight muon, veto additional leptons, and apply the minimal MET requirement. This defines the core single-lepton topology before any SR or CR classification.”</p>
<p>3.“Clean all jets (quality, pT, ΔR from the muon) and classify them as central or forward. Retain only events with at least two central jets, as required by the topology used in the analysis.”</p>
<p>4.Compute the physics variables used throughout the analysis: W transverse mass, jet multiplicities, b-tag multiplicity, minΔφ(jets,MET), forward-jet count, and mT(b). These variables are the basis for the SR/CR definitions and the later shape studies.</p>
<p>5.Package all selected events and computed variables into NumPy arrays. This standardized structure makes it easy to plot distributions, apply further event selection, or feed the results into statistical tools.</p>
<pre><code class="language-python">#import awkward as ak
#import uproot
#import numpy as np
#colorsimport vector
vector.register_awkward()

#  1.  ###################################

def process_file_muon(filename, dataset=&quot;Unknown&quot;, IS_DATA=False):

    try:
        with uproot.open(f&quot;{filename}:Events&quot;) as tree:
            muons = ak.zip({
                &quot;pt&quot;: tree[&quot;Muon_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Muon_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Muon_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Muon_mass&quot;].array(),
                &quot;iso&quot;: tree[&quot;Muon_pfRelIso04_all&quot;].array(),
                &quot;tightId&quot;: tree[&quot;Muon_tightId&quot;].array(),
                &quot;looseId&quot;: tree[&quot;Muon_looseId&quot;].array(),
            }, with_name=&quot;Momentum4D&quot;)

            electrons = ak.zip({
                &quot;pt&quot;: tree[&quot;Electron_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Electron_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Electron_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Electron_mass&quot;].array(),
                &quot;cutBased&quot;: tree[&quot;Electron_cutBased&quot;].array(), 
            }, with_name=&quot;Momentum4D&quot;)

            jets = ak.zip({
                &quot;pt&quot;: tree[&quot;Jet_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Jet_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Jet_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Jet_mass&quot;].array(),
                &quot;jetId&quot;: tree[&quot;Jet_jetId&quot;].array(),
                &quot;btag&quot;: tree[&quot;Jet_btagDeepFlavB&quot;].array(),
            }, with_name=&quot;Momentum4D&quot;)

            met_pt = tree[&quot;MET_pt&quot;].array()
            met_phi = tree[&quot;MET_phi&quot;].array()

            if not IS_DATA:
                gen_weight = tree[&quot;genWeight&quot;].array()
            else:
                gen_weight = ak.ones_like(met_pt)

##############################################################################

        # --- 2. SELECCIÓN BASELINE ---


        mu_tight_mask = (muons.pt &gt; 30) &amp; (abs(muons.eta) &lt; 2.4) &amp; (muons.tightId) &amp; (muons.iso &lt; 0.15)
        mu_loose_mask = (muons.pt &gt; 10) &amp; (abs(muons.eta) &lt; 2.4) &amp; (muons.looseId) &amp; (muons.iso &lt; 0.25)
        ele_veto_mask = (electrons.pt &gt; 10) &amp; (abs(electrons.eta) &lt; 2.5) &amp; (electrons.cutBased &gt;= 1)

        good_muons = muons[mu_tight_mask]
        veto_muons = muons[mu_loose_mask]
        veto_electrons = electrons[ele_veto_mask]

        has_1_tight_mu = (ak.num(good_muons) == 1)
        veto_extra_lep = (ak.num(veto_muons) == 1) &amp; (ak.num(veto_electrons) == 0)
        pass_met = met_pt &gt; 150 

        event_mask = has_1_tight_mu &amp; veto_extra_lep &amp; pass_met

        # Filtrado inicial
        good_muons = good_muons[event_mask]
        jets = jets[event_mask]
        met_pt = met_pt[event_mask]
        met_phi = met_phi[event_mask]
        gen_weight = gen_weight[event_mask]

        leading_mu = good_muons[:, 0]


        # 3. ###########################################################3
        jet_clean_mask = (
            (jets.pt &gt; 30) &amp; 
            (jets.jetId &gt;= 1) &amp; 
            (jets.deltaR(leading_mu) &gt; 0.4)
        )
        all_clean_jets = jets[jet_clean_mask]

        # B. Separar Central vs Forward (NUEVO)
        central_jets = all_clean_jets[abs(all_clean_jets.eta) &lt; 2.4]
        forward_jets = all_clean_jets[(abs(all_clean_jets.eta) &gt;= 2.4) &amp; (abs(all_clean_jets.eta) &lt; 5.0)]

        has_2_jets = ak.num(central_jets) &gt;= 2

        .###################################33###############################3

        # --- 4. ################################################################3
        f_met = met_pt[has_2_jets]
        f_met_phi = met_phi[has_2_jets]
        f_mu = leading_mu[has_2_jets]
        f_central = central_jets[has_2_jets]
        f_forward = forward_jets[has_2_jets]
        f_gen_weight = gen_weight[has_2_jets]

        # mT_W
        dphi_lep = f_mu.phi - f_met_phi
        mt_w = np.sqrt(2 * f_mu.pt * f_met * (1 - np.cos(dphi_lep)))

        # min DeltaPhi
        jets_top2 = f_central[:, :2]
        dphi_jets = abs(jets_top2.phi - f_met_phi)
        dphi_jets = np.mod(dphi_jets + np.pi, 2*np.pi) - np.pi
        min_dphi = ak.min(abs(dphi_jets), axis=1)

        # B-tagging
        is_btag = f_central.btag &gt; 0.2770
        n_btag = ak.sum(is_btag, axis=1)


        # 1. Conteo Forward Jets
        n_fwd = ak.num(f_forward)

        # 2. mT_b (Masa Transversa MET - Leading b-jet)
        b_jets = f_central[is_btag]
        has_b = ak.num(b_jets) &gt; 0

        # Padding seguro
        b_jet_padded = ak.fill_none(ak.firsts(b_jets), {&quot;pt&quot;: 0, &quot;phi&quot;: 0}, axis=0)
        dphi_b = b_jet_padded.phi - f_met_phi
        calc_mt_b = np.sqrt(2 * b_jet_padded.pt * f_met * (1 - np.cos(dphi_b)))

        mt_b_np = ak.to_numpy(calc_mt_b)
        has_b_np = ak.to_numpy(has_b)
        mt_b_np[~has_b_np] = -1.0 # Valor dummy

        ###############################################################################

######## 5 . #############################################################################

        return {
            &quot;dataset&quot;: dataset,
            &quot;lep_pt&quot;: ak.to_numpy(f_mu.pt),
            &quot;lep_eta&quot;: ak.to_numpy(f_mu.eta),
            &quot;met&quot;: ak.to_numpy(f_met),
            &quot;mT_W&quot;: ak.to_numpy(mt_w),
            &quot;genWeight&quot;: ak.to_numpy(f_gen_weight),
            &quot;nJet&quot;: ak.to_numpy(ak.num(f_central)),
            &quot;nBTag&quot;: ak.to_numpy(n_btag),
            &quot;min_dphi&quot;: ak.to_numpy(min_dphi),

            ## to use the processed datasets later 
            &quot;nForwardJets&quot;: ak.to_numpy(n_fwd),
            &quot;mT_b&quot;: mt_b_np
        }

    except Exception as e:
        print(f&quot;Error procesando {filename}: {e}&quot;)
        return None
</code></pre>
<p>BLOCK 1 — Dataset list (Muon Channel only)</p>
<p>This block defines the list of datasets that will be processed with the muon selection logic.</p>
<p>SingleMuon is data.</p>
<p>Everything else is MC background.
This allows the orchestrator to automatically detect whether generator weights exist.</p>
<p>BLOCK 2 — Orchestrator function</p>
<p>This function:</p>
<p>Determines whether the dataset is Data or MC.</p>
<p>Checks that the dataset exists in the global fileset.</p>
<p>Loops over the first n_files files of the dataset.</p>
<p>For each file:</p>
<p>Calls process_file_muon() (the physics function you wrote earlier).</p>
<p>Converts the returned dict into a pandas.DataFrame.</p>
<p>Merges all partial DataFrames.</p>
<p>Saves the result to a Parquet file under output_raw/.</p>
<p>Returns the full DataFrame.</p>
<p>This function does not perform physics.
Its job is to:</p>
<p>--loop</p>
<p>--collect</p>
<p>--assemble</p>
<p>--save</p>
<p>It is the “manager” layer.</p>
<p>BLOCK 3 — Execution loop</p>
<p>This simply iterates over all muon-channel datasets and processes each one with a chosen number of input ROOT files per dataset.</p>
<pre><code class="language-python">#import pandas as pd
#import os
#import awkward as ak
#import uproot
#import numpy as np
#import vector

vector.register_awkward()

# BLOCK 1 — DATASET LIST (Muon Channel Only)


datasets_muon_channel = [
    'SingleMuon',           # DATA
    'ttbar-semileptonic',   # Main background
    'ttW', 'WW', 'ZZ', 'Zvv',
    'DYJets-Zpt200',
    't-channel-top',
    'WJets-HT400to600'
]


# BLOCK 2 — ORCHESTRATOR FUNCTION (Muon Analysis Logic)

def process_dataset_muon_raw(dataset, n_files=5):
    &quot;&quot;&quot;
    High-level orchestrator:
    - Determines if dataset is Data or MC
    - Retrieves ROOT files
    - Calls the muon-physics function (process_file_muon)
    - Converts results to DataFrames
    - Concatenates them and saves as a Parquet file
    &quot;&quot;&quot;

    # Check if dataset is Data (only SingleMuon)
    is_data = &quot;SingleMuon&quot; in dataset

    print(f&quot; Processing RAW {dataset} (Is Data: {is_data})...&quot;)

    # Verify that dataset exists in the global fileset
    if dataset not in fileset:
        print(f&quot; {dataset} not found in fileset. Skipping.&quot;)
        return None

    # Select only the first n_files
    files = fileset[dataset][&quot;files&quot;][:n_files]
    dfs = []

    for f in files:
        try:
            # Call your physics selection function
            data_dict = process_file_muon(f, dataset=dataset, IS_DATA=is_data)

            # Turn dict into DataFrame
            df = pd.DataFrame(data_dict)
            dfs.append(df)

        except Exception as e:
            # A single bad file should not stop the batch
            print(f&quot; Error in file {f}: {e}&quot;)

    # If no results were generated
    if len(dfs) == 0:
        print(f&quot; No valid events produced for {dataset}&quot;)
        return None

    # Merge all dataframes
    full_df = pd.concat(dfs, ignore_index=True)

    # Save as parquet in output_raw/
    os.makedirs(&quot;output_raw&quot;, exist_ok=True)
    output_path = f&quot;output_raw/{dataset}_raw.parquet&quot;

    full_df.to_parquet(output_path, index=False)
    print(f&quot; Saved: {output_path} with {len(full_df)} events.&quot;)

    return full_df


# BLOCK 3 — EXECUTION LOOP


N_FILES = 10  # Increase to 20+ for proper statistics

print(f&quot;=== STARTING MUON PROCESSING ({N_FILES} files per dataset) ===&quot;)

for ds in datasets_muon_channel:
    process_dataset_muon_raw(ds, n_files=N_FILES)

</code></pre>
<pre><code>=== STARTING MUON PROCESSING (10 files per dataset) ===
 Processing RAW SingleMuon (Is Data: True)...
 Saved: output_raw/SingleMuon_raw.parquet with 10832 events.
 Processing RAW ttbar-semileptonic (Is Data: False)...
 Saved: output_raw/ttbar-semileptonic_raw.parquet with 108389 events.
 Processing RAW ttW (Is Data: False)...
 Saved: output_raw/ttW_raw.parquet with 85898 events.
 Processing RAW WW (Is Data: False)...
 Saved: output_raw/WW_raw.parquet with 8476 events.
 Processing RAW ZZ (Is Data: False)...
 Saved: output_raw/ZZ_raw.parquet with 100 events.
 Processing RAW Zvv (Is Data: False)...
 Saved: output_raw/Zvv_raw.parquet with 4 events.
 Processing RAW DYJets-Zpt200 (Is Data: False)...
 Saved: output_raw/DYJets-Zpt200_raw.parquet with 2240 events.
 Processing RAW t-channel-top (Is Data: False)...
 Saved: output_raw/t-channel-top_raw.parquet with 6811 events.
 Processing RAW WJets-HT400to600 (Is Data: False)...
 Saved: output_raw/WJets-HT400to600_raw.parquet with 49574 events.
</code></pre>
<h1 id="why-normalization-is-needed">— Why Normalization Is Needed</h1>
<p>This section introduces the central problem:
data and MC cannot be compared directly because:</p>
<ul>
<li>Data reflects what the detector <em>actually recorded</em>.</li>
<li>MC is generated with arbitrary numbers of events and must be rescaled.</li>
</ul>
<p>Your introduction sets the conceptual foundation:
<strong>MC must be weighted so that its event yields match the luminosity of the data sample</strong>.</p>
<h3 id="what-this-enables"><strong>What this enables</strong></h3>
<p>The next blocks will:</p>
<ul>
<li>Extract necessary metadata</li>
<li>Compute normalization weights</li>
<li>Apply them when building histograms</li>
</ul>
<p>Without this conceptual block, the following code would feel unmotivated.</p>
<hr />
<h1 id="extracting-total-generated-weights-sumgenweights">Extracting Total Generated Weights (<code>sumGenWeights</code>)</h1>
<h3 id="explanation"><strong>Explanation</strong></h3>
<p>To compute the MC weight</p>
<div class="arithmatex">\[
w = \frac{\sigma \cdot L}{N_{\text{gen}}}
\]</div>
<p>we need the denominator:
<strong>the number of generated events</strong>, usually stored as <strong>sum of generated event weights</strong>:</p>
<pre><code>Runs/genEventSumw
</code></pre>
<p>This block reads that information <em>efficiently</em> from the <code>Runs</code> tree in each file.</p>
<h3 id="what-this-block-does-for-normalization"><strong>What this block does for normalization</strong></h3>
<ul>
<li>Provides <strong>N_gen ≡ sumGenWeights</strong></li>
<li>Without it, normalization would be impossible</li>
<li>For <strong>data</strong>, you correctly set the weight to <strong>1</strong> (data is never scaled)</li>
</ul>
<pre><code class="language-python">#import uproot
#import numpy as np


sum_weights_map = {}


print(f&quot;{'Dataset':&lt;30} | {'SumW (Runs)':&lt;20}&quot;)
print(&quot;-&quot; * 60)

for dataset_name, info in fileset.items():

    # Identify data (data has no generator weights)
    is_data = any(x in dataset_name for x in [&quot;SingleMuon&quot;, &quot;SingleElectron&quot;, &quot;MET&quot;, &quot;EGamma&quot;])

    if is_data:
        sum_weights_map[dataset_name] = 1.0
        print(f&quot;{dataset_name:&lt;30} | {'1.0 (DATA)':&lt;20}&quot;)
        continue

    total_sum_w = 0.0
    file_list = info[&quot;files&quot;]

    for filename in file_list:
        try:
            with uproot.open(f&quot;{filename}:Runs&quot;) as runs:
                if &quot;genEventSumw&quot; in runs:
                    w = runs[&quot;genEventSumw&quot;].array(library=&quot;np&quot;)
                    total_sum_w += np.sum(w)
        except Exception as e:
            print(f&quot; Error reading {filename}: {e}&quot;)

    sum_weights_map[dataset_name] = total_sum_w
    print(f&quot;{dataset_name:&lt;30} | {total_sum_w:.2e}&quot;)

print(&quot;\n Normalization metadata loaded.&quot;)

</code></pre>
<pre><code>Dataset                        | SumW (Runs)         
------------------------------------------------------------
met                            | 0.00e+00
SingleMuon                     | 1.0 (DATA)          
SingleElectron                 | 1.0 (DATA)          
ttbar-semileptonic             | 4.35e+10
ttbar-hadronic                 | 3.36e+10
t-channel-top                  | 2.30e+09
ttW                            | 1.11e+06
WJets-HT400to600               | 2.12e+06
DYJets-Zpt200                  | 7.51e+03
WW                             | 1.58e+07
ZZ                             | 1.15e+06
Zvv                            | 6.47e+04

 Normalization metadata loaded.
</code></pre>
<h1 id="defining-the-physics-metadata-cross-sections-classification">Defining the Physics Metadata (Cross Sections + Classification)</h1>
<h3 id="explanation_1"><strong>Explanation</strong></h3>
<p>This block assigns:</p>
<ul>
<li><strong>Cross sections (σ)</strong></li>
<li><strong>Dataset category (ttbar, WJets, etc.)</strong></li>
<li><strong>Plotting style (colors)</strong></li>
</ul>
<p>This is where you get the numerator of the weight formula:</p>
<p>[
\sigma \cdot L
]</p>
<h3 id="how-it-connects-to-normalization"><strong>How it connects to normalization</strong></h3>
<p>You now have:</p>
<ul>
<li><strong>σ</strong> (from <code>fileset[ds]["metadata"]</code>)</li>
<li><strong>L</strong> (your chosen <code>LUM</code>)</li>
<li><strong>N_gen</strong> (from previous block)</li>
</ul>
<p>→ Everything needed to compute <strong>per-event scale factors</strong>.</p>
<pre><code class="language-python">import pandas as pd

LUM = 2590.0  # pb^-1

DATA_SL = {&quot;SingleMuon&quot;, &quot;SingleElectron&quot;}

COLOR_MAP = {
    &quot;ttbar&quot;:     &quot;#FF9933&quot;, 
    &quot;WJets&quot;:     &quot;#33CC33&quot;, 
    &quot;ZJets&quot;:     &quot;#3399FF&quot;, 
    &quot;SingleTop&quot;: &quot;#CC33CC&quot;, 
    &quot;Diboson&quot;:   &quot;#FFCC00&quot;, 
    &quot;Rare&quot;:      &quot;#FF0000&quot;, 
    &quot;Other&quot;:     &quot;#999999&quot;   
}

def get_group_info(name):

    #####################################################################################################
    if &quot;ttW&quot; in name or &quot;ttZ&quot; in name: return &quot;Rare&quot;, r&quot;$t\bar{t}V$&quot;, COLOR_MAP[&quot;Rare&quot;]
    if &quot;ttbar&quot; in name: return &quot;ttbar&quot;, r&quot;$t\bar{t}$ Semileptonic&quot;, COLOR_MAP[&quot;ttbar&quot;]
    if &quot;channel&quot; in name or &quot;tW&quot; in name: return &quot;SingleTop&quot;, r&quot;Single Top&quot;, COLOR_MAP[&quot;SingleTop&quot;]
    if &quot;WJets&quot; in name: return &quot;WJets&quot;, r&quot;W+Jets&quot;, COLOR_MAP[&quot;WJets&quot;]
    if &quot;DY&quot; in name or &quot;Zvv&quot; in name: return &quot;ZJets&quot;, r&quot;Z/$\gamma^*$+Jets&quot;, COLOR_MAP[&quot;ZJets&quot;]
    if name in [&quot;WW&quot;, &quot;ZZ&quot;, &quot;WZ&quot;]: return &quot;Diboson&quot;, r&quot;VV (Diboson)&quot;, COLOR_MAP[&quot;Diboson&quot;]
    return &quot;Other&quot;, &quot;Other&quot;, COLOR_MAP[&quot;Other&quot;]
    ###############################################################################################


print(f&quot;{'Dataset':&lt;25} | {'Xsec [pb]':&lt;10} &quot;
      f&quot;| {'SumGenWeights':&lt;15} | {'Scale Factor':&lt;12}&quot;)
print(&quot;-&quot; * 70)

datasets_general_check = list(fileset.keys())

for ds in datasets_general_check:

    # DATA
    if ds in DATA_SL:
        print(f&quot;{ds:&lt;25} | {'-':&lt;10} | {'-':&lt;15} | {'1.00':&lt;12}&quot;)
        continue

    if ds not in fileset:
        print(f&quot;{ds:&lt;25} | {'No fileset':&lt;10} | -&quot;)
        continue

    xsec = fileset[ds][&quot;metadata&quot;][&quot;xsec&quot;]
    sum_w = sum_weights_map.get(ds, 0.0)

    if sum_w &gt; 0 and xsec is not None:
        scale = (xsec * LUM) / sum_w
        scale_str = f&quot;{scale:.2e}&quot;
        if scale &gt; 10.0:
            scale_str += &quot; HIGH&quot;
        print(f&quot;{ds:&lt;25} | {xsec:&lt;10.2f} | {sum_w:&lt;15.2e} | {scale_str:&lt;12}&quot;)

    else:
        reason = &quot;SumW=0&quot; if sum_w == 0 else &quot;Xsec=None&quot;
        print(f&quot;{ds:&lt;25} | {str(xsec):&lt;10} | {sum_w:&lt;15.2e} | ERROR ({reason})&quot;)

</code></pre>
<pre><code>Dataset                   | Xsec [pb]  | SumGenWeights   | Scale Factor
----------------------------------------------------------------------
met                       | None       | 0.00e+00        | ERROR (SumW=0)
SingleMuon                | -          | -               | 1.00        
SingleElectron            | -          | -               | 1.00        
ttbar-semileptonic        | 364.35     | 4.35e+10        | 2.17e-05    
ttbar-hadronic            | 377.96     | 3.36e+10        | 2.91e-05    
t-channel-top             | 136.02     | 2.30e+09        | 1.53e-04    
ttW                       | 0.20       | 1.11e+06        | 4.75e-04    
WJets-HT400to600          | 48.91      | 2.12e+06        | 5.99e-02    
DYJets-Zpt200             | 1.27       | 7.51e+03        | 4.38e-01    
WW                        | 118.70     | 1.58e+07        | 1.94e-02    
ZZ                        | 16.60      | 1.15e+06        | 3.74e-02    
Zvv                       | 77.30      | 6.47e+04        | 3.09e+00
</code></pre>
<p>Inventory: We define exactly which datasets we want to mix.</p>
<p>Loop &amp; Load: We iterate through the list, read the processed Parquet files (which are much faster than ROOT files), and load them into RAM.</p>
<p>Normalization: We apply the physics weights immediately so every dataframe in all_dfs is ready to be plotted.</p>
<p>Visualization: We trigger the plots right at the end.</p>
<p>To produce publication-quality plots—like those found in CMS analyses—we need a function that:</p>
<ol>
<li><strong>Builds histograms for each MC process</strong>, applying the final per-event normalization weight.</li>
<li><strong>Groups MC samples by physics category</strong> (tt̄, W+jets, Single Top, Diboson, etc.).</li>
<li><strong>Stacks the MC contributions</strong> in the correct order (smallest on top) so that the final shape reflects the Standard Model expectation.</li>
<li><strong>Overlays the real DATA</strong> histogram with error bars.</li>
<li><strong>Applies CMS styling</strong>, including the “Preliminary” tag and integrated luminosity.</li>
<li>Ensures the plot is clean, readable, and suitable for analysis notes or a professional report.</li>
</ol>
<p>This function does exactly that.
By defining it once, we ensure that <strong>every observable (pT, eta, MET, jets, etc.)</strong> is plotted consistently and in the same professional format used in CMS.</p>
<hr />
<pre><code class="language-python">import mplhep as hep
import matplotlib.pyplot as plt
plt.style.use(hep.style.CMS)


def plot_grouped_stack(var_name, x_label, x_range, channel_data=&quot;SingleMuon&quot;,
                       n_bins=30, log_scale=False):

    # 1. Bines
    bins = np.linspace(x_range[0], x_range[1], n_bins + 1)

    grouped_counts = {}
    grouped_info   = {}

    # 2. AGRUPAR MC
    for name, df in all_dfs.items():

        # Ignore DATA here
        if name in DATA_SL:
            continue

        group_key, label, color = get_group_info(name)

        counts, _ = np.histogram(df[var_name], bins=bins, weights=df[&quot;final_weight&quot;])

        if group_key not in grouped_counts:
            grouped_counts[group_key] = counts
            grouped_info[group_key]   = {&quot;label&quot;: label, &quot;color&quot;: color, &quot;yield&quot;: np.sum(counts)}
        else:
            grouped_counts[group_key] += counts
            grouped_info[group_key][&quot;yield&quot;] += np.sum(counts)

    # 3. ORDENAR GRUPOS (por yield)
    active_groups = list(grouped_info.keys())
    active_groups.sort(key=lambda g: grouped_info[g][&quot;yield&quot;])  # small → top in stack

    mc_counts = []
    mc_colors = []
    mc_labels = []
    total_mc = np.zeros(n_bins)

    for g in active_groups:
        mc_counts.append(grouped_counts[g])
        mc_colors.append(grouped_info[g][&quot;color&quot;])
        mc_labels.append(grouped_info[g][&quot;label&quot;])
        total_mc += grouped_counts[g]

    # 4. DATA
    df_data = all_dfs.get(channel_data)
    if df_data is None:
        print(f&quot;ERROR: No DATA found for channel {channel_data}&quot;)
        return

    data_counts, _ = np.histogram(df_data[var_name], bins=bins)

    # 5. PLOT
    fig, ax = plt.subplots(figsize=(10, 8))

    # --- MC STACK -----
    if len(mc_counts) &gt; 0:
        hep.histplot(
            mc_counts,
            bins=bins,
            stack=True,
            histtype=&quot;fill&quot;,
            color=mc_colors,
            label=mc_labels,
            edgecolor=&quot;black&quot;,
            linewidth=1,
            ax=ax
        )

    # --- DATA -----
    hep.histplot(
        data_counts,
        bins=bins,
        histtype=&quot;errorbar&quot;,
        color=&quot;black&quot;,
        label=f&quot;{channel_data} (Data)&quot;,
        yerr=True,
        marker=&quot;o&quot;,
        markersize=5,
        ax=ax
    )

    # --- CMS Style -----
    hep.cms.label(&quot;Preliminary&quot;, data=True, lumi=2.6, year=2016, ax=ax)

    # Leyenda ordenada para que DATA quede arriba
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(reversed(handles), reversed(labels), fontsize=16, ncol=2, loc=&quot;upper right&quot;)

    # Ejes
    ax.set_xlabel(x_label, fontsize=24)
    ax.set_ylabel(&quot;Events&quot;, fontsize=24)
    ax.set_xlim(x_range)

    if log_scale:
        ax.set_yscale(&quot;log&quot;)
        ax.set_ylim(0.1, max(np.max(data_counts), np.max(total_mc)) * 500)
    else:
        ax.set_ylim(0, max(np.max(data_counts), np.max(total_mc)) * 1.5)

    plt.tight_layout()
    plt.show()

</code></pre>
<p>This block loads every muon-channel dataset from the previously generated _raw.parquet files, applies the correct normalization (data vs. Monte Carlo), assigns a final per-event weight, and stores everything inside a unified dictionary (all_dfs).
Once all datasets are normalized, we can safely call plot_grouped_stack to generate stacked MC vs. Data plots that follow a professional CMS-style presentation.</p>
<pre><code class="language-python">loaded_dfs = {}


# Full list of expected Muon datasets
datasets_muon_channel = [
    'SingleMuon',           # Data
    'ttbar-semileptonic',   # Top
    'ttW', 'WW', 'ZZ', 'Zvv', 'DYJets-Zpt200',
    't-channel-top',
    'WJets-HT400to600'      # WJets binned (GOOD)
]

for dataset in datasets_muon_channel:

    # Muon channel uses '_raw.parquet' (no electron prefix)
    path = f&quot;output_raw/{dataset}_raw.parquet&quot;

    try:
        df = pd.read_parquet(path)

        # Normalization
        if dataset in DATA_SL:
            df[&quot;final_weight&quot;] = 1.0
        else:
            xsec = fileset[dataset][&quot;metadata&quot;][&quot;xsec&quot;]
            sum_w = sum_weights_map.get(dataset, 1.0)
            if sum_w == 0:
                sum_w = 1.0
            scale = (xsec * LUM) / sum_w

            # Use genWeight if available
            if &quot;genWeight&quot; in df.columns:
                df[&quot;final_weight&quot;] = df[&quot;genWeight&quot;] * scale
            else:
                df[&quot;final_weight&quot;] = scale

        loaded_dfs[dataset] = df
        print(f&quot; Loaded: {dataset}&quot;)

    except FileNotFoundError:
        # Skip missing datasets silently
        continue

# Final dictionary with loaded Muon datasets
muon_dfs_clean = loaded_dfs

# Update all_dfs globally
all_dfs = muon_dfs_clean


# -------------------------------------------
# ---          CLEAN PLOTS               ---
# -------------------------------------------

if len(muon_dfs_clean) &gt; 0:
    mi_canal = &quot;SingleMuon&quot;

    plot_grouped_stack(&quot;mT_W&quot;, r&quot;$m_T^W$ [GeV]&quot;, (0, 200), mi_canal, log_scale=False)
    plot_grouped_stack(&quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (150, 500), mi_canal, log_scale=True)
    plot_grouped_stack(&quot;nJet&quot;, r&quot;$N_{jets}$&quot;, (2, 10), mi_canal, n_bins=8, log_scale=True)
    plot_grouped_stack(&quot;nBTag&quot;, r&quot;$N_{b-tags}$&quot;, (0, 5), mi_canal, n_bins=5, log_scale=True)

else:
    print(&quot; No data loaded. Check if the _raw.parquet files exist.&quot;)

</code></pre>
<pre><code> Loaded: SingleMuon
 Loaded: ttbar-semileptonic
 Loaded: ttW
 Loaded: WW
 Loaded: ZZ
 Loaded: Zvv
 Loaded: DYJets-Zpt200
 Loaded: t-channel-top
 Loaded: WJets-HT400to600
</code></pre>
<p><img alt="png" src="../output_61_1.png" /></p>
<p><img alt="png" src="../output_61_2.png" /></p>
<p><img alt="png" src="../output_61_3.png" /></p>
<p><img alt="png" src="../output_61_4.png" /></p>
<pre><code class="language-python">muon_dfs_clean = loaded_dfs
all_dfs = muon_dfs_clean

# ----- remover WJets -----
if &quot;WJets-HT400to600&quot; in muon_dfs_clean:
    muon_dfs_clean.pop(&quot;WJets-HT400to600&quot;)

# ----- graficar -----
if len(muon_dfs_clean) &gt; 0:
    mi_canal = &quot;SingleMuon&quot;

    plot_grouped_stack(&quot;mT_W&quot;, r&quot;$m_T^W$ [GeV]&quot;, (0, 200), mi_canal, log_scale=False)
    plot_grouped_stack(&quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (150, 500), mi_canal, log_scale=True)
    plot_grouped_stack(&quot;nJet&quot;, r&quot;$N_{jets}$&quot;, (2, 10), mi_canal, n_bins=8, log_scale=True)
    plot_grouped_stack(&quot;nBTag&quot;, r&quot;$N_{b-tags}$&quot;, (0, 5), mi_canal, n_bins=5, log_scale=True)

</code></pre>
<p><img alt="png" src="../output_62_0.png" /></p>
<p><img alt="png" src="../output_62_1.png" /></p>
<p><img alt="png" src="../output_62_2.png" /></p>
<p><img alt="png" src="../output_62_3.png" /></p>
<h2 id="electron">Electron</h2>
<p>To adapt the muon channel for the electron channel, we switch the signal object from <code>Muon</code> to <code>Electron</code> and adjust the kinematic cuts: pseudorapidity is restricted to <strong><span class="arithmatex">\(|\eta| &lt; 2.1\)</span></strong> (instead of 2.4), and a <strong>"Gap Veto"</strong> is implemented to exclude electrons in the barrel-endcap transition region (<span class="arithmatex">\(1.4442 &lt; |\eta| &lt; 1.566\)</span>). Furthermore, the identification criteria change from specific <code>tightId</code> and isolation cuts to the standard <strong><code>cutBased == 4</code></strong> (Tight ID), and <strong>Jet Cleaning</strong> is re-evaluated by requiring <span class="arithmatex">\(\Delta R &gt; 0.4\)</span> with respect to the selected electron rather than the muon.</p>
<pre><code class="language-python">#import awkward as ak
#import uproot
#import numpy as np
#import vector
#vector.register_awkward()



def process_electron(filename, dataset=&quot;Unknown&quot;, IS_DATA=False):

        with uproot.open(f&quot;{filename}:Events&quot;) as tree:
            electrons = ak.zip({
                &quot;pt&quot;: tree[&quot;Electron_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Electron_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Electron_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Electron_mass&quot;].array(),
                &quot;cutBased&quot;: tree[&quot;Electron_cutBased&quot;].array(),
            }, with_name=&quot;Momentum4D&quot;)

            muons = ak.zip({
                &quot;pt&quot;: tree[&quot;Muon_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Muon_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Muon_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Muon_mass&quot;].array(),
                &quot;looseId&quot;: tree[&quot;Muon_looseId&quot;].array(),
                &quot;iso&quot;: tree[&quot;Muon_pfRelIso04_all&quot;].array(),
            }, with_name=&quot;Momentum4D&quot;)

            jets = ak.zip({
                &quot;pt&quot;: tree[&quot;Jet_pt&quot;].array(),
                &quot;eta&quot;: tree[&quot;Jet_eta&quot;].array(),
                &quot;phi&quot;: tree[&quot;Jet_phi&quot;].array(),
                &quot;mass&quot;: tree[&quot;Jet_mass&quot;].array(),
                &quot;jetId&quot;: tree[&quot;Jet_jetId&quot;].array(),
                &quot;btag&quot;: tree[&quot;Jet_btagDeepFlavB&quot;].array(),
            }, with_name=&quot;Momentum4D&quot;)

            met_pt = tree[&quot;MET_pt&quot;].array()
            met_phi = tree[&quot;MET_phi&quot;].array()

            if not IS_DATA: gen_weight = tree[&quot;genWeight&quot;].array()
            else: gen_weight = ak.ones_like(met_pt)

        # --- 1. selection---
        in_gap = (abs(electrons.eta) &gt; 1.4442) &amp; (abs(electrons.eta) &lt; 1.566)
        ele_tight_mask = (electrons.pt &gt; 30) &amp; (abs(electrons.eta) &lt; 2.1) &amp; (electrons.cutBased == 4) &amp; (~in_gap)
        ele_veto_mask = (electrons.pt &gt; 10) &amp; (electrons.cutBased &gt;= 1)
        mu_loose_mask = (muons.pt &gt; 10) &amp; (abs(muons.eta) &lt; 2.4) &amp; (muons.looseId) &amp; (muons.iso &lt; 0.25)

        good_ele = electrons[ele_tight_mask]
        veto_ele = electrons[ele_veto_mask]
        veto_mu = muons[mu_loose_mask]

        has_1_tight = (ak.num(good_ele) == 1)
        is_exclusive = (ak.num(veto_ele) == 1) &amp; (ak.num(veto_mu) == 0)
        pass_met = met_pt &gt; 150

        event_mask = has_1_tight &amp; is_exclusive &amp; pass_met

        good_ele = good_ele[event_mask]
        jets = jets[event_mask]
        met_pt = met_pt[event_mask]
        met_phi = met_phi[event_mask]
        gen_weight = gen_weight[event_mask]
        leading_ele = good_ele[:, 0]


        # A. Cleaning with ELECTRON
        jet_clean_mask = (
            (jets.pt &gt; 30) &amp; (jets.jetId &gt;= 1) &amp; 
            (jets.deltaR(leading_ele) &gt; 0.4)
        )
        all_clean_jets = jets[jet_clean_mask]

        # B. Categories
        central_jets = all_clean_jets[abs(all_clean_jets.eta) &lt; 2.4]
        forward_jets = all_clean_jets[(abs(all_clean_jets.eta) &gt;= 2.4) &amp; (abs(all_clean_jets.eta) &lt; 5.0)]

        has_2_jets = ak.num(central_jets) &gt;= 2

        f_met = met_pt[has_2_jets]
        f_met_phi = met_phi[has_2_jets]
        f_ele = leading_ele[has_2_jets]
        f_central = central_jets[has_2_jets]
        f_forward = forward_jets[has_2_jets]
        f_gen_weight = gen_weight[has_2_jets]

        # mT
        dphi = f_ele.phi - f_met_phi
        mt = np.sqrt(2 * f_ele.pt * f_met * (1 - np.cos(dphi)))

        # min DeltaPhi
        jets_top2 = f_central[:, :2]
        dphi_jets = abs(jets_top2.phi - f_met_phi)
        dphi_jets = np.mod(dphi_jets + np.pi, 2*np.pi) - np.pi
        min_dphi = ak.min(abs(dphi_jets), axis=1)

        # B-tagging
        is_btag = f_central.btag &gt; 0.2770
        n_btag = ak.sum(is_btag, axis=1)

        # Extras
        n_fwd = ak.num(f_forward)

        b_jets = f_central[is_btag]
        has_b = ak.num(b_jets) &gt; 0
        b_jet_padded = ak.fill_none(ak.firsts(b_jets), {&quot;pt&quot;: 0, &quot;phi&quot;: 0}, axis=0)
        dphi_b = b_jet_padded.phi - f_met_phi
        calc_mt_b = np.sqrt(2 * b_jet_padded.pt * f_met * (1 - np.cos(dphi_b)))

        mt_b_np = ak.to_numpy(calc_mt_b)
        has_b_np = ak.to_numpy(has_b)
        mt_b_np[~has_b_np] = -1.0

        return {
            &quot;dataset&quot;: dataset,
            &quot;lep_pt&quot;: ak.to_numpy(f_ele.pt),
            &quot;lep_eta&quot;: ak.to_numpy(f_ele.eta),
            &quot;met&quot;: ak.to_numpy(f_met),
            &quot;mT_W&quot;: ak.to_numpy(mt),
            &quot;genWeight&quot;: ak.to_numpy(f_gen_weight),
            &quot;nJet&quot;: ak.to_numpy(ak.num(f_central)),
            &quot;nBTag&quot;: ak.to_numpy(n_btag),
            &quot;min_dphi&quot;: ak.to_numpy(min_dphi),
            &quot;nForwardJets&quot;: ak.to_numpy(n_fwd),
            &quot;mT_b&quot;: mt_b_np
        }

</code></pre>
<p>and with the same idea as the muon one</p>
<pre><code class="language-python">#import pandas as pd
#import os


datasets_electron_channel = [
    'SingleElectron',        # DATA
    'ttbar-semileptonic',    # Main Background
    'ttW',
    'WW', 'ZZ', 'Zvv',
    'DYJets-Zpt200',         # Drell–Yan (important for Z→ee)
    't-channel-top',
    'WJets-HT400to600'       # W+Jets
]

def process_dataset_electron_raw(dataset, n_files=5):
    # Explicit detection for data
    is_data = &quot;SingleElectron&quot; in dataset

    print(f&quot; Processing RAW Electron {dataset} (Is Data: {is_data})...&quot;)

    if dataset not in fileset:
        print(f&quot;{dataset} not found in fileset. Skipping.&quot;)
        return None

    files = fileset[dataset][&quot;files&quot;][:n_files]
    dfs = []

    for f in files:
        try:
            # Call the electron-level physics processing function
            # (Make sure 'process_electron' is defined earlier)
            data_dict = process_electron(f, dataset=dataset, IS_DATA=is_data)

            df = pd.DataFrame(data_dict)
            dfs.append(df)

        except Exception as e:
            # Report individual file errors without stopping the loop
            print(f&quot; Error in file {f}: {e}&quot;)

    if len(dfs) == 0:
        print(f&quot;No valid events were produced for {dataset}&quot;)
        return None

    full_df = pd.concat(dfs, ignore_index=True)

    # Save output
    os.makedirs(&quot;output_raw&quot;, exist_ok=True)

    # NOTE: we use '_electron_raw' to avoid overlapping with muon outputs
    output_path = f&quot;output_raw/{dataset}_electron_raw.parquet&quot;

    full_df.to_parquet(output_path, index=False)
    print(f&quot;Saved: {output_path} with {len(full_df)} events.&quot;)

    return full_df


# --- 3. MASS EXECUTION ---
# Use n_files=10 or more for reasonable statistics
N_FILES = 10

print(f&quot;=== STARTING ELECTRON PROCESSING ({N_FILES} files per dataset) ===&quot;)

for ds in datasets_electron_channel:
    process_dataset_electron_raw(ds, n_files=N_FILES)

</code></pre>
<pre><code>=== STARTING ELECTRON PROCESSING (10 files per dataset) ===
 Processing RAW Electron SingleElectron (Is Data: True)...
Saved: output_raw/SingleElectron_electron_raw.parquet with 10757 events.
 Processing RAW Electron ttbar-semileptonic (Is Data: False)...
Saved: output_raw/ttbar-semileptonic_electron_raw.parquet with 78228 events.
 Processing RAW Electron ttW (Is Data: False)...
Saved: output_raw/ttW_electron_raw.parquet with 60974 events.
 Processing RAW Electron WW (Is Data: False)...
Saved: output_raw/WW_electron_raw.parquet with 6141 events.
 Processing RAW Electron ZZ (Is Data: False)...
Saved: output_raw/ZZ_electron_raw.parquet with 83 events.
 Processing RAW Electron Zvv (Is Data: False)...
Saved: output_raw/Zvv_electron_raw.parquet with 24 events.
 Processing RAW Electron DYJets-Zpt200 (Is Data: False)...
Saved: output_raw/DYJets-Zpt200_electron_raw.parquet with 1398 events.
 Processing RAW Electron t-channel-top (Is Data: False)...
Saved: output_raw/t-channel-top_electron_raw.parquet with 4238 events.
 Processing RAW Electron WJets-HT400to600 (Is Data: False)...
Saved: output_raw/WJets-HT400to600_electron_raw.parquet with 35219 events.
</code></pre>
<pre><code class="language-python">def load_all_electrons_cleaned():
    loaded_dfs = {}

    datasets_electron_channel = [
        'SingleElectron', 'ttbar-semileptonic',
        'ttW', 'WW', 'ZZ', 'Zvv', 'DYJets-Zpt200',
        't-channel-top',
        'WJets-HT400to600',
    ]

    for dataset in datasets_electron_channel:
        path = f&quot;output_raw/{dataset}_electron_raw.parquet&quot;
        try:
            df = pd.read_parquet(path)

            if dataset in DATA_SL:
                df[&quot;final_weight&quot;] = 1.0
            else:
                xsec = fileset[dataset][&quot;metadata&quot;][&quot;xsec&quot;]
                sum_w = sum_weights_map.get(dataset, 1.0)
                if sum_w == 0: sum_w = 1.0
                scale = (xsec * LUM) / sum_w

                if &quot;genWeight&quot; in df.columns:
                    df[&quot;final_weight&quot;] = df[&quot;genWeight&quot;] * scale
                else:
                    df[&quot;final_weight&quot;] = scale

            loaded_dfs[dataset] = df
            print(f&quot; Cargado: {dataset}&quot;)

        except FileNotFoundError:
            continue

    return loaded_dfs


ele_dfs_clean = load_all_electrons_cleaned()

if len(ele_dfs_clean) &gt; 0:
    print(&quot;\n Generating CLEAN plots for SingleElectron...&quot;)

    all_dfs = ele_dfs_clean   # THIS CAUSES plot_grouped_stack TO USE ELECTRONS

    mi_canal = &quot;SingleElectron&quot;


    plot_grouped_stack(&quot;mT_W&quot;, r&quot;$m_T^W$ [GeV]&quot;, (0, 200), mi_canal, log_scale=False)
    plot_grouped_stack(&quot;met&quot;,  r&quot;$p_T^{miss}$ [GeV]&quot;, (150, 500), mi_canal, log_scale=True)
    plot_grouped_stack(&quot;nJet&quot;, r&quot;$N_{jets}$&quot;, (2, 10), mi_canal, n_bins=8, log_scale=True)
    plot_grouped_stack(&quot;nBTag&quot;, r&quot;$N_{b-tags}$&quot;, (0, 5), mi_canal, n_bins=5, log_scale=True)

else:
    print(&quot; No electron data was uploaded.&quot;)


</code></pre>
<pre><code> Cargado: SingleElectron
 Cargado: ttbar-semileptonic
 Cargado: ttW
 Cargado: WW
 Cargado: ZZ
 Cargado: Zvv
 Cargado: DYJets-Zpt200
 Cargado: t-channel-top
 Cargado: WJets-HT400to600

 Generating CLEAN plots for SingleElectron...
</code></pre>
<p><img alt="png" src="../output_68_1.png" /></p>
<p><img alt="png" src="../output_68_2.png" /></p>
<p><img alt="png" src="../output_68_3.png" /></p>
<p><img alt="png" src="../output_68_4.png" /></p>
<h1 id="signal-region">Signal Region</h1>
<h2 id="table-13-final-event-selection-sl-and-ah"><strong>Table 13 — Final Event Selection (SL and AH)</strong></h2>
<h3 id="what-does-it-contain_1"><strong>What does it contain?</strong></h3>
<p>The <strong>official final cuts</strong> defining the analysis <strong>Signal Regions (SR)</strong>.
Each SR is classified according to:</p>
<ul>
<li>Channel (semi-leptonic or hadronic)</li>
<li>Number of <strong>b-jets</strong></li>
<li>Presence of <strong>forward jets</strong></li>
<li>Values of <strong>MET</strong>, <strong>MT</strong>, <strong>HT</strong>, etc.</li>
</ul>
<h3 id="what-is-it-for_2"><strong>What is it for?</strong></h3>
<p>It defines the regions where <strong>dark matter signals</strong> are searched for.
These regions are fed directly into the <strong>final statistical fit</strong>.</p>
<pre><code class="language-python">
display(Image(filename=&quot;Table_13.png&quot;))

</code></pre>
<p><img alt="png" src="../output_71_0.png" /></p>
<p>Now we move to the <strong>signal region</strong>. We use the events that were already filtered by the baseline selection and then apply the additional cuts described in <strong>Table 13</strong>. To do this, we first need to load the preprocessed datasets stored as <strong>parquet</strong> files, so the following function was created.</p>
<p>This function loads only the datasets needed for the analysis channel (muon or electron)</p>
<h3 id="issues">Issues</h3>
<p>The normalization is applied again at the loading stage because the stored <strong>.parquet files do not consistently contain a final, analysis-ready weight</strong>. In some cases, the <code>final_weight</code> column is not saved at all, and in others it may have been produced using a different luminosity, a different fileset configuration, or an earlier definition of the analysis.</p>
<p>To avoid mixing inconsistent normalizations and to guarantee that all samples are treated uniformly, the normalization is recomputed at runtime using the current cross sections and the total sum of generator weights. This ensures that the final event yields are coherent and directly comparable across datasets.</p>
<pre><code class="language-python">def load_data(channel=&quot;muon&quot;):
    loaded_dfs = {}

    datasets_to_load = [
        'SingleMuon' if channel == 'muon' else 'SingleElectron',
        'ttbar-semileptonic', 'ttW', 'WW', 'ZZ', 'Zvv', 
        'DYJets-Zpt200', 't-channel-top', 'WJets-HT400to600'
    ]

    suffix = &quot;_raw.parquet&quot; if channel == &quot;muon&quot; else &quot;_electron_raw.parquet&quot;

    for ds in datasets_to_load:
        path = f&quot;output_raw/{ds}{suffix}&quot;
        try:
            df = pd.read_parquet(path)

            # Normalización
            if ds in DATA_SL:
                df[&quot;final_weight&quot;] = 1.0
            else:
                if ds not in fileset: continue
                xsec = fileset[ds][&quot;metadata&quot;][&quot;xsec&quot;]
                sum_w = sum_weights_map.get(ds, 1.0) 
                if sum_w == 0: sum_w = 1.0

                scale = (xsec * LUM) / sum_w

                if &quot;genWeight&quot; in df.columns:
                    df[&quot;final_weight&quot;] = df[&quot;genWeight&quot;] * scale
                else:
                    df[&quot;final_weight&quot;] = scale

            loaded_dfs[ds] = df

        except FileNotFoundError:
            continue

    return loaded_dfs

</code></pre>
<pre><code class="language-python">def signal_regions(df):


    if df is None or len(df) == 0: return {}

    # --- CORTES SUAVES ---
    pass_common = (
        (df[&quot;met&quot;] &gt; 160) &amp;
        (df[&quot;min_dphi&quot;] &gt; 0.5) 
    )

    df_sr = df[pass_common]
    if len(df_sr) == 0: return {}

    # Definición de las 3 Regiones (Categorías)
    mask_1b_0f = (df_sr[&quot;nBTag&quot;] == 1) &amp; (df_sr[&quot;nForwardJets&quot;] == 0)
    mask_1b_1f = (df_sr[&quot;nBTag&quot;] == 1) &amp; (df_sr[&quot;nForwardJets&quot;] &gt;= 1)
    mask_2b = (df_sr[&quot;nBTag&quot;] &gt;= 2) 

    return {
        &quot;SR_1b_0f&quot;: df_sr[mask_1b_0f],
        &quot;SR_1b_1f&quot;: df_sr[mask_1b_1f],
        &quot;SR_2b&quot;:    df_sr[mask_2b]
    }

</code></pre>
<p>Once <code>plot_grouped_stack</code> was defined, the same base code was reused to create <code>plot_region_stack</code>. The logic of the stacked histogram is the same, but extra features were added to handle analysis regions. In particular, a region label is drawn on the plot and the display is adapted to show results specific to a selected region. This keeps the core behavior unchanged while adding more flexibility for regional visualization.</p>
<p>The main changes are:</p>
<ul>
<li>A region label parameter was added to the function signature.</li>
<li>A text label was drawn on the plot using a line like:
  <code>ax.text(..., region_label, ...)</code></li>
<li>The plot title or decoration was adapted to reflect the selected region.</li>
<li>Small adjustments were made to make the function work with region-specific dictionaries.</li>
</ul>
<p>All other parts of the stacking logic (histogram creation, grouping, colors, and legends) remain unchanged.</p>
<pre><code class="language-python">def plot_region_stack(dfs_dict, region_name, var_name, x_label, x_range, channel_label, n_bins=10):

    bins = np.linspace(x_range[0], x_range[1], n_bins + 1)

    # Preparar Datos para Stack
    grouped_counts = {}
    grouped_info = {}

    for name, df in dfs_dict.items():
        if name in DATA_SL: continue 

        counts, _ = np.histogram(df[var_name], bins=bins, weights=df[&quot;final_weight&quot;])
        g_key, label, color = get_group_info(name)

        if g_key not in grouped_counts:
            grouped_counts[g_key] = counts
            grouped_info[g_key] = {&quot;label&quot;: label, &quot;color&quot;: color, &quot;yield&quot;: np.sum(counts)}
        else:
            grouped_counts[g_key] += counts
            grouped_info[g_key][&quot;yield&quot;] += np.sum(counts)

    # Ordenar Stack
    active_groups = sorted(grouped_info.keys(), key=lambda k: grouped_info[k][&quot;yield&quot;])

    mc_counts = []
    mc_colors = []
    mc_labels = []
    total_mc = np.zeros(n_bins)

    for g in active_groups:
        mc_counts.append(grouped_counts[g])
        mc_colors.append(grouped_info[g][&quot;color&quot;])
        mc_labels.append(grouped_info[g][&quot;label&quot;])
        total_mc += grouped_counts[g]

    # Datos
    df_data = dfs_dict.get(channel_label)
    data_counts = np.zeros(n_bins)
    if df_data is not None:
        data_counts, _ = np.histogram(df_data[var_name], bins=bins)

    # Graficar
    fig, ax = plt.subplots(figsize=(10, 8))

    if len(mc_counts) &gt; 0:
        hep.histplot(mc_counts, bins=bins, stack=True, histtype=&quot;fill&quot;,
                     color=mc_colors, label=mc_labels, edgecolor=&quot;black&quot;, linewidth=1, ax=ax)

    hep.histplot(data_counts, bins=bins, histtype=&quot;errorbar&quot;, color=&quot;black&quot;,
                 label=f&quot;{channel_label} (Data)&quot;, yerr=True, marker='o', markersize=5, ax=ax)

    # Decoración
    hep.cms.label(&quot;Preliminary&quot;, data=True, lumi=35.9, year=2016, ax=ax)

    # Leyenda Limpia
    handles, labels = ax.get_legend_handles_labels()
    by_label = OrderedDict(zip(labels[::-1], handles[::-1]))
    ax.legend(by_label.values(), by_label.keys(), fontsize=15, ncol=2, loc='upper right')

    # Etiqueta Interna
    ax.text(0.05, 0.93, f&quot;{region_name}&quot;, transform=ax.transAxes, 
            fontsize=20, fontweight='bold', va='top')

    ax.set_xlabel(x_label, fontsize=24)
    ax.set_ylabel(&quot;Events&quot;, fontsize=24)
    ax.set_xlim(x_range)
    ax.set_yscale(&quot;log&quot;) 

    max_y = max(np.max(data_counts), np.max(total_mc))
    ax.set_ylim(0.1, max_y * 500) 

    plt.tight_layout()
    plt.show()

</code></pre>
<pre><code class="language-python">def run_analysis_for_channel(channel_mode):

    raw_dfs = load_data(channel_mode)
    if not raw_dfs: return

    regions_db = {&quot;SR_1b_0f&quot;: {}, &quot;SR_1b_1f&quot;: {}, &quot;SR_2b&quot;: {}}
    for name, df in raw_dfs.items():
        sub_regions = signal_regions(df)
        for reg, df_reg in sub_regions.items():
            regions_db[reg][name] = df_reg

    d_label = &quot;SingleMuon&quot; if channel_mode == &quot;muon&quot; else &quot;SingleElectron&quot;

    plot_region_stack(regions_db[&quot;SR_2b&quot;], &quot;SR 2b&quot;, &quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (160, 600), d_label)
    plot_region_stack(regions_db[&quot;SR_1b_1f&quot;], r&quot;SR 1b $\geq$1f&quot;, &quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (160, 600), d_label)
    plot_region_stack(regions_db[&quot;SR_1b_0f&quot;], &quot;SR 1b 0f&quot;, &quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (160, 600), d_label)

</code></pre>
<pre><code class="language-python">from collections import OrderedDict


if 'sum_weights_map' in globals():
    run_analysis_for_channel(&quot;muon&quot;)
    run_analysis_for_channel(&quot;electron&quot;)
else:
    print(&quot; Error.&quot;)

</code></pre>
<p><img alt="png" src="../output_79_0.png" /></p>
<p><img alt="png" src="../output_79_1.png" /></p>
<p><img alt="png" src="../output_79_2.png" /></p>
<p><img alt="png" src="../output_79_3.png" /></p>
<p><img alt="png" src="../output_79_4.png" /></p>
<p><img alt="png" src="../output_79_5.png" /></p>
<h3 id="control-region">Control Region</h3>
<h2 id="table-14-control-region-definitions-sl-and-ah"><strong>Table 14 — Control Region Definitions (SL and AH)</strong></h2>
<h3 id="what-does-it-contain_2"><strong>What does it contain?</strong></h3>
<p>This table defines the <strong>Control Regions (CRs)</strong> required to calibrate and validate the main background processes in the analysis:</p>
<ul>
<li><strong>Dileptonic tt̄</strong></li>
<li><strong>W+jets</strong></li>
<li><strong>Z→νν</strong> (in the all-hadronic channel)</li>
<li><strong>Semileptonic tt̄</strong> (in the all-hadronic channel)</li>
</ul>
<h3 id="what-is-it-used-for"><strong>What is it used for?</strong></h3>
<p>These regions serve to:</p>
<ul>
<li><strong>Constrain and normalize the simulated background yields</strong></li>
<li><strong>Compare Monte Carlo predictions against real data</strong></li>
<li><strong>Reduce systematic uncertainties</strong></li>
</ul>
<p>They are essential for <strong>controlling the dominant backgrounds</strong> before extracting the signal in the Signal Regions (SRs).</p>
<pre><code class="language-python">
display(Image(filename=&quot;Table_14.png&quot;))

</code></pre>
<p><img alt="png" src="../output_82_0.png" /></p>
<pre><code class="language-python">def filter_cr_wlnu(df):
    &quot;&quot;&quot;
    Control Region: CR W(lν)
    Nombres oficiales Tabla 14:
        - SL1eWR  (electrón)
        - SL1mWR  (muón)
    &quot;&quot;&quot;
    if df is None or len(df) == 0:
        return {}

    mask = (
        (df[&quot;met&quot;] &gt;= 160) &amp;
        (df[&quot;mT_W&quot;] &gt;= 80) &amp;
        (df[&quot;nBTag&quot;] == 0) &amp;
        (df[&quot;nJet&quot;] &gt;= 2)
    )

    df_cr = df[mask]
    if len(df_cr) == 0:
        return {}

    return {&quot;CR_Wlnu&quot;: df_cr}

</code></pre>
<p>Once <code>plot_region_stack</code> was defined, the same base structure was reused to create <code>plot_cr_stack</code>. The core stacked histogram logic stays the same, but additional lines were added or modified to specialize the plot for Control Regions.</p>
<p>The main changes are:</p>
<ul>
<li>A <strong>new function name</strong> was created: <code>plot_cr_stack</code>.</li>
<li>A new input parameter was added to handle the <strong>control region label</strong> (for example: <code>region_label</code>).</li>
<li>The plot now includes a <strong>region tag drawn on the figure</strong>, added through a line like:
  <code>ax.text(..., region_label, ...)</code></li>
<li>The function was adapted to work with <strong>Control Region–filtered datasets</strong>, instead of general or signal regions.</li>
<li>The default axis ranges and binning were tuned for control-region kinematics.</li>
</ul>
<p>All histogram stacking, coloring, grouping, and legend logic remains the same as in the previous functions.</p>
<pre><code class="language-python">def plot_cr_stack(dfs_dict, region_label, var_name, x_label, x_range, data_label, n_bins=15):

    bins = np.linspace(x_range[0], x_range[1], n_bins + 1)
    grouped_counts = {}
    grouped_info = {}

    # A) MC
    for name, df in dfs_dict.items():
        if name in DATA_SL:
            continue

        counts, _ = np.histogram(df[var_name], bins=bins, weights=df[&quot;final_weight&quot;])
        g_key, label, color = get_group_info(name)

        if g_key not in grouped_counts:
            grouped_counts[g_key] = counts
            grouped_info[g_key] = {&quot;label&quot;: label, &quot;color&quot;: color, &quot;yield&quot;: np.sum(counts)}
        else:
            grouped_counts[g_key] += counts
            grouped_info[g_key][&quot;yield&quot;] += np.sum(counts)

    active_groups = sorted(grouped_info.keys(), key=lambda k: grouped_info[k][&quot;yield&quot;])

    mc_counts = []
    mc_colors = []
    mc_labels = []
    total_mc = np.zeros(n_bins)

    for g in active_groups:
        mc_counts.append(grouped_counts[g])
        mc_colors.append(grouped_info[g][&quot;color&quot;])
        mc_labels.append(grouped_info[g][&quot;label&quot;])
        total_mc += grouped_counts[g]

    # B) DATA
    df_data = dfs_dict.get(data_label)
    if df_data is not None:
        data_counts, _ = np.histogram(df_data[var_name], bins=bins)
    else:
        data_counts = np.zeros(n_bins)

    # === Plot ===
    fig, ax = plt.subplots(figsize=(10, 8))

    hep.histplot(mc_counts, bins=bins, stack=True, histtype=&quot;fill&quot;,
                 color=mc_colors, label=mc_labels, edgecolor=&quot;black&quot;, linewidth=1, ax=ax)

    hep.histplot(data_counts, bins=bins, histtype=&quot;errorbar&quot;, color=&quot;black&quot;,
                 label=f&quot;{data_label} (Data)&quot;, yerr=True, marker='o', markersize=5, ax=ax)

    hep.cms.label(&quot;Preliminary&quot;, data=True, lumi=35.9, year=2016, ax=ax)

    ax.text(0.05, 0.93, region_label, transform=ax.transAxes,
            fontsize=20, fontweight='bold', va='top', ha='left')

    handles, labels = ax.get_legend_handles_labels()
    by_label = OrderedDict(zip(labels[::-1], handles[::-1]))
    ax.legend(by_label.values(), by_label.keys(), fontsize=15, ncol=2, loc='upper right')

    ax.set_xlabel(x_label, fontsize=24)
    ax.set_ylabel(&quot;Events&quot;, fontsize=24)
    ax.set_xlim(x_range)
    ax.set_yscale(&quot;log&quot;)

    max_y = max(np.max(data_counts), np.max(total_mc))
    ax.set_ylim(0.1, max_y * 500)

    plt.tight_layout()
    plt.show()



</code></pre>
<pre><code class="language-python">
def run_SL(channel_mode):

    # 1. Load datasets
    raw_dfs = load_data(channel_mode)
    if not raw_dfs:
        return

    # 2. Filtrar región CR W(lν)
    cr_dict = {}
    for name, df in raw_dfs.items():
        reg = filter_cr_wlnu(df)
        if &quot;CR_Wlnu&quot; in reg:
            cr_dict[name] = reg[&quot;CR_Wlnu&quot;]

    if len(cr_dict) == 0:
        print(&quot; No events passed CR W(lν).&quot;)
        return

    # 3. Etiquetas correctas según Tabla 14
    if channel_mode == &quot;muon&quot;:
        region_label = &quot;SL1mWR&quot;
        data_label = &quot;SingleMuon&quot;
    else:
        region_label = &quot;SL1eWR&quot;
        data_label = &quot;SingleElectron&quot;


    # plot MET
    plot_cr_stack(cr_dict, region_label, &quot;met&quot;, r&quot;$p_T^{miss}$ [GeV]&quot;, (160, 600), data_label, n_bins=15)

    # plot MT
    #plot_cr_stack(cr_dict, region_label, &quot;mT_W&quot;, r&quot;$m_T^W$ [GeV]&quot;, (160, 500), data_label, n_bins=15)


# --- RUN ---
run_SL(&quot;muon&quot;)
run_SL(&quot;electron&quot;)
</code></pre>
<p><img alt="png" src="../output_86_0.png" /></p>
<p><img alt="png" src="../output_86_1.png" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../../All_Hadronic/all%20hadronic%20si/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Complete Guide: AH Optimization Analysis for CMS Open Data">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Complete Guide: AH Optimization Analysis for CMS Open Data
              </div>
            </div>
          </a>
        
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.footer"], "search": "../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>