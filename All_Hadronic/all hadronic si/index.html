
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Search for dark matter produced in association with a single top quark or a top quark pair in proton-proton collisions at √s = 13 TeV">
      
      
      
        <link rel="canonical" href="https://cms-epn.github.io/search-for-dark-matter-docs/All_Hadronic/all%20hadronic%20si/">
      
      
        <link rel="prev" href="../..">
      
      
        <link rel="next" href="../../Single_Lepton/Single_lepton_comment/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.21">
    
    
      
        <title>All hadronic chanel - Search for dark matter</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.2a3383ac.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i,700,700i%7CRed+Hat+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Merriweather Sans";--md-code-font:"Red Hat Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="blue-grey">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#all-hadronic-chanel" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Search for dark matter" class="md-header__button md-logo" aria-label="Search for dark matter" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 11a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1M4.22 4.22C5.65 2.79 8.75 3.43 12 5.56c3.25-2.13 6.35-2.77 7.78-1.34s.79 4.53-1.34 7.78c2.13 3.25 2.77 6.35 1.34 7.78s-4.53.79-7.78-1.34c-3.25 2.13-6.35 2.77-7.78 1.34S3.43 15.25 5.56 12C3.43 8.75 2.79 5.65 4.22 4.22m11.32 4.24c.61.62 1.17 1.25 1.69 1.88 1.38-2.13 1.88-3.96 1.13-4.7-.74-.75-2.57-.25-4.7 1.13.63.52 1.26 1.08 1.88 1.69m-7.08 7.08c-.61-.62-1.17-1.25-1.69-1.88-1.38 2.13-1.88 3.96-1.13 4.7.74.75 2.57.25 4.7-1.13-.63-.52-1.26-1.08-1.88-1.69m-2.82-9.9c-.75.74-.25 2.57 1.13 4.7.52-.63 1.08-1.26 1.69-1.88.62-.61 1.25-1.17 1.88-1.69-2.13-1.38-3.96-1.88-4.7-1.13m4.24 8.48c.7.7 1.42 1.34 2.12 1.91.7-.57 1.42-1.21 2.12-1.91s1.34-1.42 1.91-2.12c-.57-.7-1.21-1.42-1.91-2.12S12.7 8.54 12 7.97c-.7.57-1.42 1.21-2.12 1.91S8.54 11.3 7.97 12c.57.7 1.21 1.42 1.91 2.12m8.48 4.24c.75-.74.25-2.57-1.13-4.7-.52.63-1.08 1.26-1.69 1.88-.62.61-1.25 1.17-1.88 1.69 2.13 1.38 3.96 1.88 4.7 1.13"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Search for dark matter
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              All hadronic chanel
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="blue-grey"  aria-label="Dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="deep-orange"  aria-label="Light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/CMS-EPN/search-for-dark-matter-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    search-for-dark-matter-docs
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Search for dark matter" class="md-nav__button md-logo" aria-label="Search for dark matter" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 11a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1M4.22 4.22C5.65 2.79 8.75 3.43 12 5.56c3.25-2.13 6.35-2.77 7.78-1.34s.79 4.53-1.34 7.78c2.13 3.25 2.77 6.35 1.34 7.78s-4.53.79-7.78-1.34c-3.25 2.13-6.35 2.77-7.78 1.34S3.43 15.25 5.56 12C3.43 8.75 2.79 5.65 4.22 4.22m11.32 4.24c.61.62 1.17 1.25 1.69 1.88 1.38-2.13 1.88-3.96 1.13-4.7-.74-.75-2.57-.25-4.7 1.13.63.52 1.26 1.08 1.88 1.69m-7.08 7.08c-.61-.62-1.17-1.25-1.69-1.88-1.38 2.13-1.88 3.96-1.13 4.7.74.75 2.57.25 4.7-1.13-.63-.52-1.26-1.08-1.88-1.69m-2.82-9.9c-.75.74-.25 2.57 1.13 4.7.52-.63 1.08-1.26 1.69-1.88.62-.61 1.25-1.17 1.88-1.69-2.13-1.38-3.96-1.88-4.7-1.13m4.24 8.48c.7.7 1.42 1.34 2.12 1.91.7-.57 1.42-1.21 2.12-1.91s1.34-1.42 1.91-2.12c-.57-.7-1.21-1.42-1.91-2.12S12.7 8.54 12 7.97c-.7.57-1.42 1.21-2.12 1.91S8.54 11.3 7.97 12c.57.7 1.21 1.42 1.91 2.12m8.48 4.24c.75-.74.25-2.57-1.13-4.7-.52.63-1.08 1.26-1.69 1.88-.62.61-1.25 1.17-1.88 1.69 2.13 1.38 3.96 1.88 4.7 1.13"/></svg>

    </a>
    Search for dark matter
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CMS-EPN/search-for-dark-matter-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    search-for-dark-matter-docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    EPN CMS collaboration
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    All Hadronic
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            All Hadronic
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    All hadronic chanel
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    All hadronic chanel
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#physics-motivation-and-channel-strategy-all-hadronic-channel" class="md-nav__link">
    <span class="md-ellipsis">
      Physics Motivation and Channel Strategy: All-Hadronic Channel
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#channel-strategy" class="md-nav__link">
    <span class="md-ellipsis">
      Channel Strategy
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Single Lepton
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Single Lepton
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Single_Lepton/Single_lepton_comment/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Single Lepton
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#physics-motivation-and-channel-strategy-all-hadronic-channel" class="md-nav__link">
    <span class="md-ellipsis">
      Physics Motivation and Channel Strategy: All-Hadronic Channel
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#channel-strategy" class="md-nav__link">
    <span class="md-ellipsis">
      Channel Strategy
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="all-hadronic-chanel">All hadronic chanel</h1>
<h2 id="physics-motivation-and-channel-strategy-all-hadronic-channel">Physics Motivation and Channel Strategy: All-Hadronic Channel</h2>
<p>The Large Hadron Collider (LHC) collides protons at center-of-mass energies high enough to probe physics beyond the Standard Model. Although the protons are composite objects, the relevant hard scatterings occur between their constituents — quarks and gluons. In the context of simplified dark matter models, these partonic interactions can produce top quarks together with a new mediator particle (commonly denoted φ for scalar or a for pseudoscalar). The mediator then decays invisibly into a pair of dark matter candidates (χχ̄). At the detector level, this results in events with multiple top quarks plus significant missing transverse momentum (p_T^miss), the latter coming from the invisible χ particles.</p>
<p>The production mechanisms of interest include:</p>
<p>• <strong>Gluon fusion:</strong>
  $$ gg \to t \bar{t}\,\phi \to t \bar{t} + \chi \bar{\chi} $$</p>
<p>• <strong>Single top associated production:</strong>
  $$ gb \to t \phi \to t + \chi \bar{\chi} $$</p>
<p>• <strong>t–channel production:</strong>
  $$ qq' \to tb \phi \to tb + \chi \bar{\chi} $$</p>
<p>In all cases, the top quarks decay via <span class="arithmatex">\(t \to W b\)</span>. Each W boson subsequently decays either leptonically (<span class="arithmatex">\(W \to \ell \nu\)</span>) or hadronically (<span class="arithmatex">\(W \to q \bar{q}'\)</span>). Thus, the final states contain a mixture of b-tagged jets, light-flavor jets, charged leptons (electrons or muons), and genuine <span class="arithmatex">\(p_T^{\text{miss}}\)</span>.</p>
<h2 id="channel-strategy">Channel Strategy</h2>
<p>Because of the different W decay modes, analyses are divided into channels, each defined by the number of isolated charged leptons:</p>
<p>• <strong>Single-lepton (SL):</strong> one isolated electron or muon, several jets (including ≥1 b-tag), and nonzero <span class="arithmatex">\(p_T^{\text{miss}}\)</span>. This channel is statistically powerful and relatively clean, striking a balance between signal sensitivity and manageable backgrounds.</p>
<p>• <strong>All-hadronic (AH):</strong> no isolated leptons, many jets including b-tagged jets, and <span class="arithmatex">\(p_T^{\text{miss}}\)</span>. While it has the largest raw yield, it suffers from overwhelming QCD multijet background, which can fake <span class="arithmatex">\(p_T^{\text{miss}}\)</span>.</p>
<p>• <strong>Dilepton:</strong> two isolated leptons, large <span class="arithmatex">\(p_T^{\text{miss}}\)</span>, and multiple jets. It provides a very clean signal region but is limited by low branching fraction, hence low statistics.</p>
<p><strong>In this notebook, we concentrate on the all-hadronic channel with no isolated leptons.</strong></p>
<p>There are both theoretical and practical reasons for this choice:</p>
<ul>
<li>
<p><strong>From the physics side:</strong> The AH channel has the highest branching ratio (~46% for <span class="arithmatex">\(t\bar{t}\)</span>) since both W bosons decay hadronically. This provides maximum statistical power despite the challenging QCD background.</p>
</li>
<li>
<p><strong>From the experimental side:</strong> Dedicated MET-based triggers and stringent angular cuts can effectively suppress QCD contamination. The presence of multiple b-jets further enhances signal-to-background discrimination.</p>
</li>
</ul>
<p>This focus allows us to demonstrate the full workflow — from event selection to histograms — in a setting where the interplay between signal characteristics and background processes can be clearly explained. Splitting into channels is therefore not a stylistic decision but a physics necessity: each final state probes the same underlying processes under different background conditions and detector signatures.</p>
<hr />
<h1 id="software-setup-and-package-imports">Software Setup and Package Imports</h1>
<p>Before we start analyzing data, we need to set up the software environment. This section imports the Python packages that allow us to read CMS NanoAOD files, manipulate event data, and produce plots in a reproducible and physics-oriented way.</p>
<p>• <strong>Core utilities:</strong>
  - <code>os</code>, <code>time</code>, <code>json</code>, <code>logging</code>, <code>asyncio</code> → for file handling, timing, and bookkeeping.
  - These are standard Python libraries that help organize the workflow and log progress.</p>
<p>• <strong>Numerical analysis:</strong>
  - <code>numpy</code> (<code>np</code>) → fundamental for vectorized calculations on arrays.
  - <code>pandas</code> (<code>pd</code>) → convenient for storing metadata (cross sections, cutflows, etc.) in table form.</p>
<p>• <strong>Visualization:</strong>
  - <code>matplotlib</code> (<code>mpl</code>, <code>plt</code>) → general-purpose plotting.
  - <code>hist</code> → modern histogramming library designed for HEP, integrates smoothly with <code>mplhep</code>.</p>
<p>• <strong>HEP-specific data access:</strong>
  - <code>uproot</code> → reads CMS <code>.root</code> files into Python without needing C++/ROOT. Essential for open data workflows.
  - <code>awkward</code> (<code>ak</code>) → handles "jagged arrays" (variable-length collections per event), e.g. different numbers of jets per event.
  - <code>vector</code> → enables 4-vector operations (pT, eta, phi, invariant masses) in a NumPy/Awkward-friendly way. We register it with Awkward to use directly on event data.</p>
<p>• <strong>Coffea ecosystem:</strong>
  - <code>coffea.processor</code> → framework to run HEP analyses at scale.
  - <code>NanoAODSchema</code> and <code>NanoEventsFactory</code> → provide a high-level interface to CMS NanoAOD, automatically building event objects like muons, jets, MET, etc.
  - <code>transforms</code> and <code>methods.base/vector</code> → ensure physics-style behavior (Lorentz vectors, masks, object methods) are available on Awkward arrays.</p>
<p>Finally, we configure Coffea to ignore unusual cross-references in CMS open data (they don't affect our analysis) and print the versions of the key packages. This ensures reproducibility: anyone re-running the notebook can confirm they are using the same software environment.</p>
<pre><code class="language-python">import asyncio, logging, os, time, json
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import hist
import uproot
import awkward as ak
import vector as v
v.register_awkward()

# Coffea
from coffea import processor
from coffea.nanoevents import NanoAODSchema, NanoEventsFactory
from coffea.nanoevents import transforms
from coffea.nanoevents.methods import base, vector as cvector

# Ensure Coffea behaviors are available on Awkward objects
ak.behavior.update(base.behavior)
ak.behavior.update(cvector.behavior)

# Be gentle with open-data odd cross-refs
NanoAODSchema.warn_missing_crossrefs = False

import coffea
print(&quot;versions:&quot;,
      &quot;coffea&quot;, coffea.__version__,
      &quot;| awkward&quot;, ak.__version__,
      &quot;| uproot&quot;, uproot.__version__)
</code></pre>
<hr />
<h1 id="dataset-definitions-and-luminosity-masks">Dataset Definitions and Luminosity Masks</h1>
<p>The CMS Open Data portal provides access to collision and simulation datasets in the NanoAOD format. Each dataset (e.g. MET, TTToHadronic, W+jets) is split across many <code>.root</code> files, sometimes hundreds per process. To manage this efficiently, we build a Python dictionary <code>nanoaod_filenames</code> that maps process names to their corresponding file index lists. Each entry points to a <code>.txt</code> file containing the remote paths (via XRootD) of the NanoAOD files.</p>
<p><strong>Examples:</strong></p>
<p>• <strong>Data (collision events):</strong> <code>MET</code>. These correspond to recorded events with MET-based trigger paths.</p>
<p>• <strong>Signal MC:</strong> e.g. hypothetical <span class="arithmatex">\(t\bar{t} + DM\)</span> samples.</p>
<p>• <strong>Background MC:</strong> top pair production (hadronic, semileptonic, dileptonic), single top (t-channel, tW), and electroweak processes like W+jets, Z→νν, or dibosons (WW, ZZ).</p>
<p>This separation is not just organizational:</p>
<ul>
<li>
<p><strong>From a physics perspective,</strong> each dataset represents a different process contributing to the observed events. Signal vs. background categories are crucial for defining the search strategy.</p>
</li>
<li>
<p><strong>From a programming perspective,</strong> keeping datasets in a dictionary allows us to iterate over them in loops, automate file loading, and apply the same selections consistently.</p>
</li>
</ul>
<h2 id="luminosity-masks">Luminosity Masks</h2>
<p>Real CMS data are recorded in luminosity sections (blocks of events). Not all sections are usable: some are flagged as problematic by the detector monitoring. To ensure reproducibility, CMS provides certified luminosity JSON files, which specify the "good" sections.</p>
<p>The function <code>build_lumi_mask()</code> implements this filter:</p>
<p>• Reads the certified JSON file.
• Compares the <code>run</code> and <code>luminosityBlock</code> of each event to the approved ranges.
• Returns a boolean mask selecting only events in certified sections.</p>
<p>This step is critical in real data analysis:</p>
<ul>
<li><strong>Physics motivation:</strong> prevents contamination from detector malfunctions.</li>
</ul>
<h2 id="helper-functions">Helper Functions</h2>
<p>• <code>get_files_for_dataset(dataset, random=False, n=0)</code> → loads a subset of filenames for a given dataset. Useful when testing code with fewer files to save time.</p>
<p>• <code>pretty_print(fields, ...)</code> → formats lists of branches or variables, making the NanoAOD structure easier to inspect.</p>
<p>Together, these utilities allow us to handle dozens of datasets and millions of events in a manageable, modular way.</p>
<pre><code class="language-python">import dpoa_workshop
from dpoa_workshop import nanoaod_filenames
from dpoa_workshop import get_files_for_dataset
from dpoa_workshop import pretty_print
from dpoa_workshop import build_lumi_mask
</code></pre>
<hr />
<h1 id="building-the-ntuple-file-index">Building the Ntuple File Index</h1>
<p>CMS Open Data provides file index text files (<code>file_index.txt</code>) for each dataset. These contain the actual XRootD paths to the NanoAOD <code>.root</code> files, along with metadata such as the number of events per file.</p>
<p>To streamline the workflow:</p>
<p>• We define a function <code>download_and_parse_fileindex(url)</code> that fetches each <code>file_index.txt</code> via HTTP and extracts only the ROOT file paths.</p>
<p>• We loop over all entries in <code>nanoaod_filenames</code> (the dictionary we built earlier) and collect the full list of ROOT files per dataset.</p>
<p>• The result is stored in a new dictionary <code>ntuples_simple</code>, which maps dataset → list of ROOT file paths.</p>
<p>• Finally, we save this as a JSON file (<code>ntuples_simple.json</code>) for later reuse.</p>
<pre><code class="language-python">import os, json, requests
from dpoa_workshop import nanoaod_filenames

def download_and_parse_fileindex(url):
    &quot;&quot;&quot;Download a file_index.txt and return list of ROOT paths.&quot;&quot;&quot;
    r = requests.get(url)
    lines = [ln.strip() for ln in r.text.splitlines() if ln.strip()]
    # Each line is: root://... nevts=N
    paths = [ln.split()[0] for ln in lines]
    return paths

ntuples_simple = {}

# Loop through nanoaod_filenames and save only paths
for dataset, urls in nanoaod_filenames.items():
    all_paths = []
    for url in urls:
        try:
            all_paths.extend(download_and_parse_fileindex(url))
        except Exception as e:
            print(f&quot;[warn] {dataset} {url} -&gt; {e}&quot;)

    ntuples_simple[dataset] = all_paths

# Save the JSON
with open(&quot;ntuples_simple.json&quot;, &quot;w&quot;) as f:
    json.dump(ntuples_simple, f, indent=2)

print(&quot;ntuples_simple.json created with datasets:&quot;, list(ntuples_simple.keys()))
</code></pre>
<hr />
<h1 id="analysis-configuration">Analysis Configuration</h1>
<p>We first define which datasets to analyze. This includes data (<code>MET</code>) and several MC backgrounds (ttbar, single top, W+jets, dibosons, Z→νν, etc.).</p>
<p>We also set controls for testing:</p>
<p>• <code>N_FILES_MAX_PER_SAMPLE</code>: how many ROOT files per dataset.
• <code>MAX_EVENTS_PER_FILE</code>: how many events to read per file.</p>
<p>This allows us to run quickly on subsets of data before scaling to the full analysis.</p>
<pre><code class="language-python"># ================================
# Initial configuration
# ================================
DATASETS_TO_RUN = [
    &quot;MET&quot;,
    &quot;ttbar-hadronic&quot;,
    &quot;ttbar-semileptonic&quot;,
    &quot;t-channel-top&quot;,
    &quot;ttW&quot;,
    &quot;WJets-HT400to600&quot;,
    &quot;WJets-2J-FxFx&quot;,
    &quot;DYJets-Zpt200&quot;,
    &quot;Zvv&quot;,
    &quot;ZZ&quot;,
    &quot;WW&quot;,
]

# Limit ROOTs and events
N_FILES_MAX_PER_SAMPLE = 1  # use only 1 ROOT file per dataset
MAX_EVENTS_PER_FILE = 50000  # None = use all events

# Luminosity (fb^-1)
LUMI_FB = 1.0

# JSON with paths to the ROOTs
NTUPLES_JSON = &quot;ntuples_simple.json&quot;
</code></pre>
<hr />
<h1 id="constructing-the-fileset">Constructing the Fileset</h1>
<p>We construct a fileset, which is a dictionary that maps each dataset name to:</p>
<p>• A list of ROOT file paths.
• Metadata such as process name, cross section, and variation.</p>
<p>This abstraction allows us to loop over datasets uniformly later, regardless of whether they are data or MC.</p>
<pre><code class="language-python">import json

def construct_fileset_simple(
    n_files_max_per_sample=1,
    ntuples_json=&quot;ntuples_simple.json&quot;
):
    with open(ntuples_json) as f:
        info = json.load(f)

    fileset = {}
    for key, files in info.items():
        if key not in DATASETS_TO_RUN:
            continue

        # limit number of files
        if n_files_max_per_sample == -1:
            use_files = files
        else:
            use_files = files[:n_files_max_per_sample]

        # normalize file list
        file_list = [f[&quot;path&quot;] if isinstance(f, dict) else f for f in use_files]

        fileset[key] = {
            &quot;files&quot;: file_list,
            &quot;metadata&quot;: {
                &quot;process&quot;: key,
                &quot;dataset&quot;: key,
                &quot;variation&quot;: &quot;nominal&quot;,
            }
        }

    return fileset

# --- construct fileset ---
fileset = construct_fileset_simple(
    n_files_max_per_sample=N_FILES_MAX_PER_SAMPLE,
    ntuples_json=NTUPLES_JSON
)

print(f&quot;[OK] Fileset constructed with {len(fileset)} datasets&quot;)
for k, pack in fileset.items():
    print(f&quot;  {k}: {len(pack['files'])} file(s)&quot;)
</code></pre>
<hr />
<h1 id="baseline-event-selection-all-hadronic-channel">Baseline Event Selection: All-Hadronic Channel</h1>
<p>We now define the baseline cuts for the all-hadronic channel with no isolated leptons. These are motivated by CMS dark matter searches and are designed to suppress dominant Standard Model backgrounds (mainly QCD multijet, <span class="arithmatex">\(t\bar{t}\)</span>, and W/Z+jets) while enhancing sensitivity to dark matter signals with real <span class="arithmatex">\(p_T^{\text{miss}}\)</span>.</p>
<h2 id="1-trigger-requirements">1. Trigger Requirements</h2>
<p>Events are selected if they fire any of the following HLT paths:</p>
<p>• <code>HLT_PFMETNoMu120</code>
• <code>HLT_PFMETNoMu90_PFMHTNoMu90_IDTight</code>
• <code>HLT_PFMETNoMu110_PFMHTNoMu110_IDTight</code>
• <code>HLT_PFMETNoMu120_PFMHTNoMu120_IDTight</code>
• <code>HLT_PFMETNoMu90_JetIdCleaned_PFMHTNoMu90_IDTight</code>
• <code>HLT_PFMETNoMu120_JetIdCleaned_PFMHTNoMu120_IDTight</code>
• <code>HLT_PFMET120_PFMHT120</code>
• <code>HLT_PFMET110_PFMHT110_IDTight</code>
• <code>HLT_PFMET120_PFMHT120_IDTight</code>
• <code>HLT_PFMET170</code>
• <code>HLT_PFMET170_NoiseCleaned</code>
• <code>HLT_PFMET170_HBHECleaned</code>
• <code>HLT_PFMET170_HBHE_BeamHaloCleaned</code></p>
<p><strong>Motivation:</strong> These MET-based triggers are efficient for hadronic final states with genuine missing energy.</p>
<h2 id="2-event-cleaning-flags">2. Event Cleaning Flags</h2>
<p>The following filters must be applied to both data and simulation:</p>
<p>• <code>HBHENoiseFilter</code>
• <code>HBHENoiseIsoFilter</code>
• <code>ECALDeadCellFilter</code>
• <code>GlobalTightHalo2016Filter</code>
• <code>BadPFMuonFilter</code>
• <code>BadChargedHadronFilter</code></p>
<p>The following filters are applied to data only:</p>
<p>• <code>EEBadScFilter</code>
• <code>BadMuons</code>
• <code>DuplicateMuons</code></p>
<p><strong>Motivation:</strong> Remove events with detector noise and instrumental fake MET.</p>
<h2 id="3-lepton-veto">3. Lepton Veto</h2>
<p>• <strong>No "Veto" Leptons:</strong> Events must contain no "Veto" leptons.
  - <strong>Electrons:</strong> No electrons with <span class="arithmatex">\(p_T &gt; 10\)</span> GeV, <span class="arithmatex">\(|\eta| &lt; 2.5\)</span>, and loose ID.
  - <strong>Muons:</strong> No muons with <span class="arithmatex">\(p_T &gt; 10\)</span> GeV, <span class="arithmatex">\(|\eta| &lt; 2.4\)</span>, and loose ID.</p>
<p><strong>Motivation:</strong> Suppress semileptonic <span class="arithmatex">\(t\bar{t}\)</span>, W+jets, and dilepton backgrounds.</p>
<h2 id="4-jet-selection">4. Jet Selection</h2>
<p>• <strong>Jet <span class="arithmatex">\(p_T\)</span>:</strong> &gt; 30 GeV
• <strong>Jet Eta:</strong>
  - Central jets: <span class="arithmatex">\(|\eta| &lt; 2.4\)</span>
  - Forward jets: <span class="arithmatex">\(2.4 &lt; |\eta| &lt; 5\)</span> (optional, depending on analysis)
• <strong>Jet ID:</strong> Loose jet ID requirements
• <strong>Overlap Removal:</strong> Jet objects are not considered if they are within <span class="arithmatex">\(\Delta R &lt; 0.4\)</span> of a "Tight" electron or muon.</p>
<p><strong>Motivation:</strong> Ensure well-reconstructed jets while avoiding double-counting with leptons.</p>
<h2 id="5-minimum-number-of-jets">5. Minimum Number of Jets</h2>
<p>• <strong>Baseline:</strong> ≥ 3 jets</p>
<p><strong>Motivation:</strong> Top decays produce at least 6 quarks in the <span class="arithmatex">\(t\bar{t}\)</span> fully hadronic channel (2 b-quarks + 4 light quarks from W decays). Requiring ≥3 jets ensures we capture the event topology.</p>
<h2 id="6-minimum-number-of-b-tagged-jets">6. Minimum Number of b-tagged Jets</h2>
<p>• <strong>Baseline:</strong> ≥ 1 b-tagged jet (CSVM working point) with <span class="arithmatex">\(p_T &gt; 30\)</span> GeV
• <strong>Categorization:</strong>
  - <span class="arithmatex">\(n_b = 1\)</span> (for single top + DM events)
  - <span class="arithmatex">\(n_b ≥ 2\)</span> (for <span class="arithmatex">\(t\bar{t}\)</span> + DM events)</p>
<p><strong>Motivation:</strong> Top-quark decays always produce b-jets, so this suppresses W+light-flavor jets and QCD.</p>
<h2 id="7-met-requirements">7. MET Requirements</h2>
<p>• <strong>Baseline:</strong> <span class="arithmatex">\(p_T^{\text{miss}} ≥ 250\)</span> GeV</p>
<p><strong>Motivation:</strong> Dark matter escapes undetected → large genuine MET. This high threshold strongly suppresses QCD multijet background.</p>
<h2 id="8-angular-separation-cuts">8. Angular Separation: Δφ Cuts</h2>
<p>• <strong>Baseline:</strong> <span class="arithmatex">\(\min\Delta\phi(j_{1,2}, p_T^{\text{miss}}) &gt; 0.4\)</span>
• <strong>Optimized Selection:</strong> <span class="arithmatex">\(\min\Delta\phi(j_{1,2}, p_T^{\text{miss}}) &gt; 1.0\)</span></p>
<p><strong>Motivation:</strong> Reduces QCD multijet events with mismeasured MET aligned with jets. True MET from dark matter is typically more isotropic.</p>
<h2 id="9-additional-kinematic-variables">9. Additional Kinematic Variables</h2>
<p>• <strong>b–MET Transverse Mass (<span class="arithmatex">\(M_{bT}\)</span>):</strong>
  - <span class="arithmatex">\(M_{bT} &gt; 180\)</span> GeV
  - <strong>Motivation:</strong> Further discriminates signal from <span class="arithmatex">\(t\bar{t}\)</span> backgrounds by exploiting the kinematics of b-quarks and MET.</p>
<p>• <strong>Jet 1 <span class="arithmatex">\(p_T\)</span> / <span class="arithmatex">\(H_T\)</span>:</strong>
  - ≤ 0.5 (specifically for <span class="arithmatex">\(n_b ≥ 2\)</span> category)
  - <strong>Motivation:</strong> Reduces events where a single jet dominates the hadronic activity, which is characteristic of QCD.</p>
<hr />
<h2 id="summary">Summary</h2>
<p>The baseline selection region is defined by:</p>
<p>• MET-based triggers (no leptons required)
• Event cleaning filters
• <strong>No veto leptons</strong> (electrons or muons with <span class="arithmatex">\(p_T &gt; 10\)</span> GeV)
• ≥ 3 jets with ≥ 1 b-tag
• Large MET (<span class="arithmatex">\(p_T^{\text{miss}} ≥ 250\)</span> GeV)
• Angular separation to suppress QCD (<span class="arithmatex">\(\min\Delta\phi(j_{1,2}, p_T^{\text{miss}}) &gt; 0.4\)</span> or <span class="arithmatex">\(&gt; 1.0\)</span>)
• Additional kinematic cuts (<span class="arithmatex">\(M_{bT} &gt; 180\)</span> GeV, jet <span class="arithmatex">\(p_T\)</span> / <span class="arithmatex">\(H_T\)</span> ≤ 0.5)</p>
<p>Together, these cuts target signal-like topologies while removing the bulk of Standard Model backgrounds, especially the overwhelming QCD multijet contamination.</p>
<hr />
<h1 id="analysis-implementation">Analysis Implementation</h1>
<p>This class (<code>DMAnalysisAllHadronic</code>) encodes the physics selection of the analysis for the all-hadronic channel:</p>
<p>• <strong>Object-level cuts:</strong>
  - Veto loose electrons: <span class="arithmatex">\(p_T &gt; 10\)</span> GeV, <span class="arithmatex">\(|\eta| &lt; 2.5\)</span>, loose ID.
  - Veto loose muons: <span class="arithmatex">\(p_T &gt; 10\)</span> GeV, <span class="arithmatex">\(|\eta| &lt; 2.4\)</span>, loose ID.
  - Jets: <span class="arithmatex">\(p_T &gt; 30\)</span> GeV, <span class="arithmatex">\(|\eta| &lt; 2.4\)</span>, good jetID.
  - b-jets: tagged with DeepCSV/DeepFlav WP.</p>
<p>• <strong>Event-level cuts:</strong>
  - Pass MET-based triggers (HLT).
  - No veto leptons (0 electrons, 0 muons).
  - ≥3 jets, ≥1 b-jet.
  - <span class="arithmatex">\(p_T^{\text{miss}} ≥ 250\)</span> GeV.
  - <span class="arithmatex">\(\min\Delta\phi(j_{1,2}, p_T^{\text{miss}}) &gt; 0.4\)</span>.</p>
<p>• <strong>Outputs:</strong>
  - Histograms for physics variables.
  - Cutflow (number of events passing each step).</p>
<pre><code class="language-python">import time, pickle
from pathlib import Path
import numpy as np
import awkward as ak
import hist
from coffea.nanoevents import NanoAODSchema, NanoEventsFactory

# === Function to read events from a ROOT file with optional limit ===
def events_from_file(path, metadata=None, schemaclass=NanoAODSchema, max_events=None):
    &quot;&quot;&quot;
    Load events from a ROOT file.
    If max_events is not None, only read up to that number of events (useful for quick tests).
    &quot;&quot;&quot;
    factory = NanoEventsFactory.from_root(
        {path: &quot;Events&quot;},
        schemaclass=schemaclass,
        metadata=(metadata or {}),
        entry_stop=max_events,
    )
    return factory.events()

# === Main class for Dark Matter analysis (All-Hadronic channel) ===
class DMAnalysisAllHadronic:
    def __init__(self, DATASET, lumi_fb):
        self.DATASET = DATASET
        self.lumi_fb = float(lumi_fb)

        # Histogram axes
        self.process_cat = hist.axis.StrCategory([], name=&quot;process&quot;, label=&quot;Process&quot;, growth=True)
        self.variation_cat = hist.axis.StrCategory([], name=&quot;variation&quot;, label=&quot;Variation&quot;, growth=True)

        # Physics variables
        num_axis = hist.axis.Regular(15, 0, 15, name=&quot;var&quot;)      # njets, nbjets
        met_axis = hist.axis.Regular(30, 0, 600, name=&quot;var&quot;)     # MET
        dphi_axis = hist.axis.Regular(32, 0, 3.2, name=&quot;var&quot;)    # min deltaphi
        ht_axis = hist.axis.Regular(40, 0, 2000, name=&quot;var&quot;)     # HT
        mbt_axis = hist.axis.Regular(30, 0, 600, name=&quot;var&quot;)     # M_bT

        # Histograms
        self.h = {
            'njets':    hist.Hist(num_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
            'nbjets':   hist.Hist(num_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
            'met':      hist.Hist(met_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
            'min_dphi': hist.Hist(dphi_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
            'ht':       hist.Hist(ht_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
            'mbt':      hist.Hist(mbt_axis, self.process_cat, self.variation_cat, storage=hist.storage.Weight()),
        }

        # Cutflow
        self.cut_flow = {
            &quot;All&quot;: 0,
            &quot;HLT_MET&quot;: 0,
            &quot;Filters&quot;: 0,
            &quot;LeptonVeto&quot;: 0,
            &quot;&gt;=3jets&quot;: 0,
            &quot;&gt;=1btag&quot;: 0,
            &quot;MET&gt;=250&quot;: 0,
            &quot;minDPhi&gt;0.4&quot;: 0,
        }

    # ---------- helpers ----------
    def _pass_met_hlt(self, events):
        &quot;&quot;&quot;Apply MET-based HLT paths.&quot;&quot;&quot;
        hlt = getattr(events, &quot;HLT&quot;, None)
        if hlt is None:
            return ak.ones_like(events.event, dtype=bool)

        hlt_paths = [
            &quot;PFMETNoMu120&quot;,
            &quot;PFMETNoMu90_PFMHTNoMu90_IDTight&quot;,
            &quot;PFMETNoMu110_PFMHTNoMu110_IDTight&quot;,
            &quot;PFMETNoMu120_PFMHTNoMu120_IDTight&quot;,
            &quot;PFMET120_PFMHT120&quot;,
            &quot;PFMET110_PFMHT110_IDTight&quot;,
            &quot;PFMET120_PFMHT120_IDTight&quot;,
            &quot;PFMET170&quot;,
        ]

        masks = []
        for name in hlt_paths:
            if hasattr(hlt, name):
                masks.append(ak.values_astype(getattr(hlt, name), bool))

        if not masks:
            return ak.ones_like(events.event, dtype=bool)

        # Logical OR of all triggers
        combined = masks[0]
        for m in masks[1:]:
            combined = combined | m
        return combined

    def _pass_event_filters(self, events):
        &quot;&quot;&quot;Apply event cleaning flags.&quot;&quot;&quot;
        flag = getattr(events, &quot;Flag&quot;, None)
        if flag is None:
            return ak.ones_like(events.event, dtype=bool)

        required_flags = [
            &quot;HBHENoiseFilter&quot;,
            &quot;HBHENoiseIsoFilter&quot;,
            &quot;EcalDeadCellTriggerPrimitiveFilter&quot;,
            &quot;globalSuperTightHalo2016Filter&quot;,
            &quot;BadPFMuonFilter&quot;,
        ]

        mask = ak.ones_like(events.event, dtype=bool)
        for fname in required_flags:
            if hasattr(flag, fname):
                mask = mask &amp; ak.values_astype(getattr(flag, fname), bool)

        return mask

    def _select_veto_electrons(self, events):
        &quot;&quot;&quot;Veto loose electrons: pt &gt; 10, |eta| &lt; 2.5.&quot;&quot;&quot;
        el = events.Electron
        if hasattr(el, &quot;cutBased&quot;):
            return el[(el.pt &gt; 10) &amp; (abs(el.eta) &lt; 2.5) &amp; (el.cutBased &gt;= 1)]
        return el[(el.pt &gt; 10) &amp; (abs(el.eta) &lt; 2.5)]

    def _select_veto_muons(self, events):
        &quot;&quot;&quot;Veto loose muons: pt &gt; 10, |eta| &lt; 2.4.&quot;&quot;&quot;
        mu = events.Muon
        if hasattr(mu, &quot;looseId&quot;):
            return mu[(mu.pt &gt; 10) &amp; (abs(mu.eta) &lt; 2.4) &amp; (mu.looseId == True)]
        return mu[(mu.pt &gt; 10) &amp; (abs(mu.eta) &lt; 2.4)]

    def _select_good_jets(self, events):
        &quot;&quot;&quot;Jets: pt &gt; 30, |eta| &lt; 2.4, jetId &gt;= 2.&quot;&quot;&quot;
        jets = events.Jet
        jetid = getattr(jets, &quot;jetId&quot;, ak.zeros_like(jets.pt, dtype=np.int32) + 2)
        return jets[(jets.pt &gt; 30) &amp; (abs(jets.eta) &lt; 2.4) &amp; (jetid &gt;= 2)]

    def _count_bjets(self, jets):
        &quot;&quot;&quot;Count b-tagged jets (DeepFlav or DeepCSV medium WP).&quot;&quot;&quot;
        if hasattr(jets, &quot;btagDeepFlavB&quot;):
            mask = jets.btagDeepFlavB &gt; 0.3093  # medium WP
        elif hasattr(jets, &quot;btagDeepB&quot;):
            mask = jets.btagDeepB &gt; 0.6321      # medium WP
        else:
            mask = ak.zeros_like(jets.pt, dtype=bool)
        return ak.sum(mask, axis=1), mask

    def _compute_min_dphi(self, jets, met):
        &quot;&quot;&quot;Compute min delta phi between leading 2 jets and MET.&quot;&quot;&quot;
        if ak.any(ak.num(jets) &gt;= 2):
            jet1 = jets[:, 0]
            jet2 = jets[:, 1]
            dphi1 = abs(jet1.phi - met.phi)
            dphi2 = abs(jet2.phi - met.phi)
            dphi1 = ak.where(dphi1 &gt; np.pi, 2*np.pi - dphi1, dphi1)
            dphi2 = ak.where(dphi2 &gt; np.pi, 2*np.pi - dphi2, dphi2)
            min_dphi = ak.where(dphi1 &lt; dphi2, dphi1, dphi2)
        else:
            min_dphi = ak.zeros_like(met.pt) + 999.0
        return min_dphi

    def _compute_ht(self, jets):
        &quot;&quot;&quot;Compute HT = scalar sum of jet pT.&quot;&quot;&quot;
        return ak.sum(jets.pt, axis=1)

    def _compute_mbt(self, bjets, met):
        &quot;&quot;&quot;Compute transverse mass between leading b-jet and MET.&quot;&quot;&quot;
        if ak.any(ak.num(bjets) &gt;= 1):
            bjet_lead = bjets[:, 0]
            mbt = np.sqrt(2.0 * bjet_lead.pt * met.pt * 
                         (1.0 - np.cos(bjet_lead.phi - met.phi)))
        else:
            mbt = ak.zeros_like(met.pt)
        return mbt

    def _weights(self, events):
        &quot;&quot;&quot;Weights disabled: return 1 for each event.&quot;&quot;&quot;
        return np.ones(len(events), dtype=&quot;float64&quot;)

    def _labels_array(self, label, n):
        return np.array([label] * int(n), dtype=object)

    def _fill_event_hist(self, H, var_np, process, variation, w_np):
        H.fill(
            var=var_np,
            process=self._labels_array(process, len(var_np)),
            variation=self._labels_array(variation, len(var_np)),
            weight=w_np
        )

    # ---------- main pipeline ----------
    def process(self, events):
        process = events.metadata.get(&quot;process&quot;, &quot;unknown&quot;)
        variation = events.metadata.get(&quot;variation&quot;, &quot;nominal&quot;)

        w_evt = self._weights(events)
        self.cut_flow[&quot;All&quot;] += len(events)

        # HLT
        hltmask = self._pass_met_hlt(events)
        events = events[hltmask]
        w_evt = w_evt[ak.to_numpy(hltmask)]
```python
        self.cut_flow[&quot;HLT_MET&quot;] += len(events)

        # Event filters
        filtermask = self._pass_event_filters(events)
        events = events[filtermask]
        w_evt = w_evt[ak.to_numpy(filtermask)]
        self.cut_flow[&quot;Filters&quot;] += len(events)

        # Lepton veto (no veto electrons, no veto muons)
        el_veto = self._select_veto_electrons(events)
        mu_veto = self._select_veto_muons(events)
        mask_lep = (ak.num(el_veto) == 0) &amp; (ak.num(mu_veto) == 0)
        events = events[mask_lep]
        w_evt = w_evt[ak.to_numpy(mask_lep)]
        self.cut_flow[&quot;LeptonVeto&quot;] += len(events)

        # Jets
        jets = self._select_good_jets(events)
        nj = ak.num(jets)

        # &gt;= 3 jets
        jets_ok = (nj &gt;= 3)
        events = events[jets_ok]
        jets = jets[jets_ok]
        nj = nj[jets_ok]
        w_evt = w_evt[ak.to_numpy(jets_ok)]
        self.cut_flow[&quot;&gt;=3jets&quot;] += len(events)

        if len(events) == 0:
            return {&quot;nevents&quot;: {process: 0}, &quot;hists&quot;: self.h}

        # b-jets
        nb, btag_mask = self._count_bjets(jets)
        bjets = jets[btag_mask]

        # &gt;= 1 b-tag
        btag_ok = (nb &gt;= 1)
        events = events[btag_ok]
        jets = jets[btag_ok]
        bjets = bjets[btag_ok]
        nj = nj[btag_ok]
        nb = nb[btag_ok]
        w_evt = w_evt[ak.to_numpy(btag_ok)]
        self.cut_flow[&quot;&gt;=1btag&quot;] += len(events)

        if len(events) == 0:
            return {&quot;nevents&quot;: {process: 0}, &quot;hists&quot;: self.h}

        # MET
        met = getattr(events, &quot;MET&quot;, None)
        met_pt = met.pt if (met is not None and hasattr(met, &quot;pt&quot;)) else ak.zeros_like(events.event, dtype=float)

        # MET &gt;= 250 GeV
        met_ok = (met_pt &gt;= 250)
        events = events[met_ok]
        jets = jets[met_ok]
        bjets = bjets[met_ok]
        nj = nj[met_ok]
        nb = nb[met_ok]
        met_pt = met_pt[met_ok]
        met = met[met_ok]
        w_evt = w_evt[ak.to_numpy(met_ok)]
        self.cut_flow[&quot;MET&gt;=250&quot;] += len(events)

        if len(events) == 0:
            return {&quot;nevents&quot;: {process: 0}, &quot;hists&quot;: self.h}

        # min delta phi
        min_dphi = self._compute_min_dphi(jets, met)

        # min delta phi &gt; 0.4
        dphi_ok = (min_dphi &gt; 0.4)
        events = events[dphi_ok]
        jets = jets[dphi_ok]
        bjets = bjets[dphi_ok]
        nj = nj[dphi_ok]
        nb = nb[dphi_ok]
        met_pt = met_pt[dphi_ok]
        met = met[dphi_ok]
        min_dphi = min_dphi[dphi_ok]
        w_evt = w_evt[ak.to_numpy(dphi_ok)]
        self.cut_flow[&quot;minDPhi&gt;0.4&quot;] += len(events)

        if len(events) == 0:
            return {&quot;nevents&quot;: {process: 0}, &quot;hists&quot;: self.h}

        # Additional kinematic variables
        ht = self._compute_ht(jets)
        mbt = self._compute_mbt(bjets, met)

        # Fill histograms
        w_evt_np = ak.to_numpy(w_evt)
        self._fill_event_hist(self.h['njets'], ak.to_numpy(nj), process, variation, w_evt_np)
        self._fill_event_hist(self.h['nbjets'], ak.to_numpy(nb), process, variation, w_evt_np)
        self._fill_event_hist(self.h['met'], ak.to_numpy(met_pt), process, variation, w_evt_np)
        self._fill_event_hist(self.h['min_dphi'], ak.to_numpy(min_dphi), process, variation, w_evt_np)
        self._fill_event_hist(self.h['ht'], ak.to_numpy(ht), process, variation, w_evt_np)
        self._fill_event_hist(self.h['mbt'], ak.to_numpy(mbt), process, variation, w_evt_np)

        # Return both histos and filtered events
        return {
            &quot;nevents&quot;: {process: int(len(w_evt_np))},
            &quot;hists&quot;: self.h,
            &quot;selected_events&quot;: events,
            &quot;jets&quot;: jets,
            &quot;bjets&quot;: bjets,
            &quot;njets&quot;: nj,
            &quot;nbjets&quot;: nb,
            &quot;met&quot;: met_pt,
            &quot;min_dphi&quot;: min_dphi,
            &quot;ht&quot;: ht,
            &quot;mbt&quot;: mbt,
        }

    def postprocess(self, accumulator):
        return accumulator
</code></pre>
<hr />
<h1 id="running-the-analysis">Running the Analysis</h1>
<p>Now we run the main loop:</p>
<ol>
<li>Iterate over each dataset in the fileset.</li>
<li>Read events from ROOT files with <code>events_from_file</code>.</li>
<li>Apply the physics cuts with <code>analysis.process</code>.</li>
<li>Save results:
   • Per-dataset CSVs with selected event variables.
   • Histograms (pickled) for plotting later.
   • Cutflow table to verify event selection efficiency.
   • Event counts for normalization.</li>
</ol>
<p>This is the driver stage where the analysis is executed.</p>
<pre><code class="language-python">from pathlib import Path
import pandas as pd
import awkward as ak
import pickle, time
import numpy as np

OUT_DIR = Path(&quot;./outputs_ah&quot;)
OUT_DIR.mkdir(parents=True, exist_ok=True)

OUT_HISTOS = OUT_DIR / &quot;dm_histograms_ah.pkl&quot;
OUT_CUTFLOW = OUT_DIR / &quot;dm_cutflow_ah.csv&quot;
OUT_NEVENTS = OUT_DIR / &quot;dm_nevents_ah.csv&quot;

analysis = DMAnalysisAllHadronic(DATASET=&quot;MET&quot;, lumi_fb=LUMI_FB)

entries_total = 0
nevents_rows = []

t0 = time.monotonic()

for key, pack in fileset.items():
    flist = pack[&quot;files&quot;]
    meta = pack[&quot;metadata&quot;]

    if not flist:
        continue

    events_all = []

    for path in flist:
        md = dict(meta)

        try:
            ev = events_from_file(path, metadata=md, max_events=MAX_EVENTS_PER_FILE)
        except Exception as e:
            print(f&quot;[warn] skip {path} -&gt; {e}&quot;)
            continue

        entries_total += len(ev)

        # --- run analysis ---
        out = analysis.process(ev)
        nsel = list(out[&quot;nevents&quot;].values())[0]

        if nsel == 0:
            continue

        # --- use filtered events for CSV ---
        ev_sel = out[&quot;selected_events&quot;]
        jets = out[&quot;jets&quot;]
        bjets = out[&quot;bjets&quot;]
        nj = out[&quot;njets&quot;]
        nb = out[&quot;nbjets&quot;]
        met_pt = out[&quot;met&quot;]
        min_dphi = out[&quot;min_dphi&quot;]
        ht = out[&quot;ht&quot;]
        mbt = out[&quot;mbt&quot;]

        df_ev = pd.DataFrame({
            &quot;process&quot;: [md[&quot;process&quot;]]*len(ev_sel),
            &quot;dataset&quot;: [md[&quot;dataset&quot;]]*len(ev_sel),
            &quot;njets&quot;: ak.to_numpy(nj),
            &quot;nbjets&quot;: ak.to_numpy(nb),
            &quot;met&quot;: ak.to_numpy(met_pt),
            &quot;min_dphi&quot;: ak.to_numpy(min_dphi),
            &quot;ht&quot;: ak.to_numpy(ht),
            &quot;mbt&quot;: ak.to_numpy(mbt),
        })

        events_all.append(df_ev)

        nevents_rows.append({
            &quot;key&quot;: key,
            &quot;process&quot;: md[&quot;process&quot;],
            &quot;dataset&quot;: md[&quot;dataset&quot;],
            &quot;file&quot;: path,
            &quot;selected_events&quot;: int(len(df_ev)),
            &quot;entries_in_file&quot;: int(len(ev)),
            &quot;xsec&quot;: md.get(&quot;xsec&quot;, None),
        })

    # Export CSV for this dataset
    if events_all:
        df_all = pd.concat(events_all, ignore_index=True)
        outfile = OUT_DIR / f&quot;{key}_processed.csv&quot;
        df_all.to_csv(outfile, index=False)
        print(f&quot;[OK] Wrote {len(df_all)} events -&gt; {outfile}&quot;)

# Save global results
elapsed = time.monotonic() - t0

with open(OUT_HISTOS, &quot;wb&quot;) as f:
    pickle.dump(analysis.h, f, protocol=pickle.HIGHEST_PROTOCOL)

pd.DataFrame(list(analysis.cut_flow.items()), columns=[&quot;cut&quot;,&quot;events&quot;]).to_csv(OUT_CUTFLOW, index=False)
pd.DataFrame(nevents_rows).to_csv(OUT_NEVENTS, index=False)

print(f&quot;\n[OK] Total entries processed: {entries_total}&quot;)
print(f&quot;[OK] Global cutflow:\n{analysis.cut_flow}&quot;)
print(f&quot;[timing] Elapsed: {elapsed:.2f} s&quot;)
</code></pre>
<hr />
<h1 id="visualization-raw-event-counts">Visualization: Raw Event Counts</h1>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import pickle
import pandas as pd
import mplhep as hep

# Apply CMS style
plt.style.use(hep.style.CMS)

# Load histograms and nevents
df_nevents = pd.read_csv(OUT_NEVENTS)

with open(OUT_HISTOS, &quot;rb&quot;) as f:
    hdict = pickle.load(f)

def plot_all_variables_raw(hdict, lumi_fb):
    &quot;&quot;&quot;
    Plot all variables without any normalization:
    - MET as data (points with error bars).
    - All other datasets as MC (stacked histograms).
    &quot;&quot;&quot;
    variables = list(hdict.keys())
    print(&quot;Available variables:&quot;, variables)

    for var in variables:
        h = hdict[var]
        processes = list(h.axes[&quot;process&quot;])
        edges = h.axes[&quot;var&quot;].edges
        centers = 0.5*(edges[:-1] + edges[1:])
        width = np.diff(edges)

        # Explicitly define data vs MC
        data_procs = [&quot;MET&quot;]
        mc_procs = [p for p in processes if p not in data_procs]

        plt.figure(figsize=(7,5))
        bottom = np.zeros(len(edges)-1)

        # --- MC stacked ---
        for proc in mc_procs:
            vals = h[{&quot;process&quot;: proc}].values().ravel()
            if np.any(vals):
                plt.bar(edges[:-1], vals, width=width, bottom=bottom,
                       align=&quot;edge&quot;, alpha=0.7, label=proc)
                bottom += vals

        # --- Data as points ---
        for proc in data_procs:
            if proc in processes:
                vals = h[{&quot;process&quot;: proc}].values().ravel()
                if np.any(vals):
                    yerr = np.sqrt(vals)
                    plt.errorbar(centers, vals, yerr=yerr,
                               fmt=&quot;o&quot;, color=&quot;black&quot;, label=proc)

        plt.xlabel(var)
        plt.ylabel(&quot;Raw events&quot;)
        plt.legend(fontsize=8, frameon=False)
        plt.grid(True, linestyle=&quot;--&quot;, alpha=0.4)
        plt.tight_layout()
        plt.show()

# === Run ===
plot_all_variables_raw(hdict, LUMI_FB)
</code></pre>
<hr />
<h1 id="cross-sections-and-normalization">Cross-Sections and Normalization</h1>
<h2 id="why-normalization-is-necessary">Why Normalization is Necessary</h2>
<p>When comparing data and Monte Carlo (MC) simulations, the raw event counts are not directly comparable:</p>
<p>• <strong>Data:</strong>
  - Events are collected with a detector during a given time period.
  - The "size" of the dataset is controlled by the integrated luminosity (L).
  - Example: UL2016 MET dataset corresponds to ~35.9 fb⁻¹.
  - There is no cross section attached — it is just what was recorded.</p>
<p>• <strong>MC (simulations):</strong>
  - Each simulated dataset corresponds to a particular physics process (e.g. <span class="arithmatex">\(t\bar{t}\)</span>, W+jets).
  - Generators simulate a finite number of events (N_gen) with a known theoretical cross section (σ).
  - By construction, MC samples may represent more or fewer events than would be seen in real data.
  - Therefore, they must be scaled.</p>
<h2 id="the-normalization-formula">The Normalization Formula</h2>
<p>To make MC comparable to data, we apply a per-event weight:</p>
<div class="arithmatex">\[ w = \frac{\sigma \cdot L}{N_\text{gen}} \]</div>
<p>Where:</p>
<p>• σ (pb) = process cross section (from theory/measurements).
• L (fb⁻¹) = integrated luminosity of the data sample.
  - Convert to pb⁻¹ by multiplying by 1000.
• N_gen = total number of generated MC events (before cuts).</p>
<p>This weight ensures that when we sum the MC events after applying cuts, the histograms reflect the expected yield in the same luminosity as the data.</p>
<h2 id="step-1-define-cross-sections">Step 1 — Define Cross-Sections</h2>
<p>For each simulated process (MC), we need the theoretical cross section (σ) in pb. This will later be combined with the luminosity (L) and the number of generated events (N_gen) to normalize MC histograms.</p>
<pre><code class="language-python"># ================================
# Cross-sections (pb) — official values
# ================================
XSEC_PB = {
    # Data-like (no cross section)
    (&quot;MET&quot;, None): None,
    (&quot;SingleMuon&quot;, None): None,
    (&quot;SingleElectron&quot;, None): None,

    # ttbar
    (&quot;ttbar-semileptonic&quot;, None): 831.76,
    (&quot;ttbar-hadronic&quot;, None): 831.76,

    # single top
    (&quot;t-channel-top&quot;, None): 136.0,
    (&quot;t-channel-antitop&quot;, None): 81.0,
    (&quot;tW-top&quot;, None): 71.7,

    # ttV
    (&quot;ttW&quot;, None): 0.204,
    (&quot;ttZ&quot;, None): 0.252,

    # W+jets
    (&quot;WJets-HT400to600&quot;, None): 48.9,
    (&quot;WJets-2J-FxFx&quot;, None): 615.7,

    # DY+jets
    (&quot;DYJets-inclusive&quot;, None): 6025.0,
    (&quot;DYJets-Zpt200&quot;, None): 1.27,

    # Diboson + Z→νν
    (&quot;Zvv&quot;, None): 77.3,
    (&quot;WW&quot;, None): 118.7,
    (&quot;ZZ&quot;, None): 16.6,
}

def get_xsec(proc: str, subgroup: str | None = None):
    &quot;&quot;&quot;
    Return cross-section (pb) for (proc, subgroup).
    Data-like samples (MET, SingleMuon, SingleElectron) return None.
    &quot;&quot;&quot;
    key = (proc, subgroup)
    if key in XSEC_PB:
        return XSEC_PB[key]
    return XSEC_PB.get((proc, None), None)

print(&quot;=== Cross-sections (pb) ===&quot;)
for (proc, subgroup), xsec in XSEC_PB.items():
    name = proc if subgroup is None else f&quot;{proc} ({subgroup})&quot;
    print(f&quot;{name:20s} : {xsec}&quot;)
</code></pre>
<h2 id="step-2-count-generated-events">Step 2 — Count Generated Events</h2>
<p>We need to know how many events were generated (N_gen) for each dataset. This is critical to compute normalization factors.</p>
<pre><code class="language-python">import uproot

def count_events_one_file(root_path):
    try:
        with uproot.open(root_path) as f:
            return f[&quot;Events&quot;].num_entries
    except Exception as e:
        print(f&quot;[warn] could not open {root_path} -&gt; {e}&quot;)
        return 0

# Dictionary to store counts
events_count = {}

for key, pack in fileset.items():
    fpaths = pack[&quot;files&quot;][:N_FILES_MAX_PER_SAMPLE]
    if not fpaths:
        continue

    total_events = 0
    file_events = []

    for path in fpaths:
        nevts = count_events_one_file(path)
        total_events += nevts
        file_events.append((path, nevts))
        print(f&quot;{key}: {path}, events={nevts}&quot;)

    events_count[key] = {
        &quot;files&quot;: fpaths,
        &quot;file_events&quot;: file_events,
        &quot;total_events&quot;: total_events,
    }

    print(f&quot;--&gt; {key}: total_events={total_events}\n&quot;)

# --- Final summary ---
print(&quot;\nSummary (per dataset):&quot;)
grand_total = 0
for k, v in events_count.items():
    print(f&quot;  {k:25s} → total_events={v['total_events']} (from {len(v['files'])} file(s))&quot;)
    grand_total += v[&quot;total_events&quot;]

print(f&quot;\n[OK] Grand total across datasets = {grand_total}&quot;)
</code></pre>
<hr />
<h1 id="normalized-plots">Normalized Plots</h1>
<pre><code class="language-python"># ================================
# Normalization + CMS-style plots
# ================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pickle

# Set your analysis luminosity (fb^-1)
LUMI_FB = 0.01

# Load histograms
with open(OUT_HISTOS, &quot;rb&quot;) as f:
    hdict = pickle.load(f)

# Explicit N_gen dictionary (truth-level generated events)
N_EVENTS_GEN = {
    &quot;MET&quot;: 1654969,
    &quot;SingleMuon&quot;: 14113,
    &quot;SingleElectron&quot;: 2338304,
    &quot;ttbar-semileptonic&quot;: 1233000,
    &quot;ttbar-hadronic&quot;: 1344000,
    &quot;t-channel-top&quot;: 168000,
    &quot;ttW&quot;: 9451,
    &quot;WJets-HT400to600&quot;: 41364,
    &quot;WJets-2J-FxFx&quot;: 1766801,
    &quot;DYJets-Zpt200&quot;: 9748,
    &quot;WW&quot;: 2016000,
    &quot;ZZ&quot;: 4000,
    &quot;Zvv&quot;: 932,
}

def get_neq_gen(proc: str) -&gt; int|None:
    &quot;&quot;&quot;N_gen = from fixed dictionary.&quot;&quot;&quot;
    return N_EVENTS_GEN.get(proc, None)

def norm_factor(proc: str, lumi_fb: float) -&gt; float:
    if proc in (&quot;SingleMuon&quot;, &quot;SingleElectron&quot;, &quot;MET&quot;):
        return 1.0

    xsec = get_xsec(proc)
    ngen = get_neq_gen(proc)

    if (xsec is None) or (ngen is None) or (ngen &lt;= 0):
        return 1.0

    return (xsec * lumi_fb * 1e3) / float(ngen)

def build_norm_report(hdict, lumi_fb):
    some_var = next(iter(hdict.keys()))
    processes = list(hdict[some_var].axes[&quot;process&quot;])

    rows = []
    for proc in processes:
        xsec = get_xsec(proc)
        ngen = get_neq_gen(proc)
        factor = norm_factor(proc, lumi_fb)

        rows.append({
            &quot;process&quot;: proc,
            &quot;xsec_pb&quot;: xsec,
            &quot;lumi_fb&quot;: lumi_fb if xsec is not None else None,
            &quot;N_gen_used&quot;: ngen,
            &quot;scale_factor&quot;: factor,
            &quot;is_data&quot;: proc in (&quot;SingleMuon&quot;, &quot;SingleElectron&quot;, &quot;MET&quot;),
        })

    return pd.DataFrame(rows)

def plot_all_variables_normalized(hdict, lumi_fb):
    rep = build_norm_report(hdict, lumi_fb)
    print(&quot;\n=== Normalization report (All-Hadronic Channel) ===&quot;)
    print(rep.to_string(index=False))

    variables = list(hdict.keys())

    for var in variables:
        h = hdict[var]
        processes = list(h.axes[&quot;process&quot;])
        edges = h.axes[&quot;var&quot;].edges
        centers = 0.5*(edges[:-1] + edges[1:])
        width = np.diff(edges)

        data_procs = [p for p in processes if p in (&quot;MET&quot;, &quot;SingleMuon&quot;, &quot;SingleElectron&quot;)]
        mc_procs = [p for p in processes if p not in data_procs]

        plt.figure(figsize=(7,5))
        bottom = np.zeros(len(edges)-1)

        for proc in mc_procs:
            vals = h[{&quot;process&quot;: proc}].values().ravel()
            vals *= norm_factor(proc, lumi_fb)
            if np.any(vals):
                plt.bar(edges[:-1], vals, width=width, bottom=bottom,
                       align=&quot;edge&quot;, alpha=0.7, label=proc)
                bottom += vals

        for proc in data_procs:
            vals = h[{&quot;process&quot;: proc}].values().ravel()
            if np.any(vals):
                yerr = np.sqrt(vals)
                plt.errorbar(centers, vals, yerr=yerr, fmt=&quot;o&quot;, color=&quot;black&quot;, label=proc)

        plt.xlabel(var)
        plt.ylabel(&quot;Events (MC scaled, Data raw)&quot;)
        plt.legend(fontsize=8, frameon=False)
        plt.grid(True, linestyle=&quot;--&quot;, alpha=0.4)
        plt.tight_layout()
        plt.show()

# === Run ===
plot_all_variables_normalized(hdict, LUMI_FB)
</code></pre>
<hr />
<p>This completes the all-hadronic channel analysis workflow with proper event selection, MET-based triggers, lepton veto, angular cuts to suppress QCD, and normalized MC-to-data comparisons.
<img alt="" src="https://cernbox-codimd.web.cern.ch/uploads/upload_e6d2ccd0232ead0e9dace280397c1025.png" />
<img alt="" src="https://cernbox-codimd.web.cern.ch/uploads/upload_2bbea8e7d9227f60d5ec884e8b46ce5d.png" />
<img alt="" src="https://cernbox-codimd.web.cern.ch/uploads/upload_eee2846d99d4ce904bb97e28bd589184.png" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../.." class="md-footer__link md-footer__link--prev" aria-label="Previous: EPN CMS collaboration">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                EPN CMS collaboration
              </div>
            </div>
          </a>
        
        
          
          <a href="../../Single_Lepton/Single_lepton_comment/" class="md-footer__link md-footer__link--next" aria-label="Next: Single Lepton">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Single Lepton
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.footer"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>